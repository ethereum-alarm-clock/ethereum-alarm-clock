{
    "Alarm": {
        "code": "0x6060604052606061016f80611a7c833950506040516101cf819003906000f060405160038054600160a060020a0319169290921790915561016f80611a7c833901809050604051809103906000f060405160048054600160a060020a03191692909217909155610d9080611beb833901809050604051809103906000f0600c8054600160a060020a0319169190911790556119dd8061009f6000396000f300606060405236156101ed5760e060020a6000350463022bc71f811461023057806303d6d7b6146102a5578063086ae9e4146102d057806309c975df146102ee57806312d67c5f146103115780631302188c1461031b578063234917d4146103265780632874fb17146103435780632a472ae81461035b5780632e1a7d4d1461038257806334c19b93146103b257806335b28153146103d25780633664a0ea1461041d5780633de622751461042857806352afbc331461043157806353a0dc7d146104595780635539d400146104cc57806360b831e5146104e0578063662fc8a014610513578063685c234a146105275780636ff96d17146105745780636ffc08961461058c57806375428615146105b357806377b19cd51461063e57806378bc64601461065b5780638b37e65614610679578063930df7b11461069f57806394d2b21b146106bc57806394f3f81d146106d0578063a9743c681461071a578063aa4cc01f14610737578063aa6704da1461075e578063b0ac4c8c14610779578063b0f07e44146107ea578063b1b1af7b14610837578063cd06273414610855578063da0774ad1461087f578063e19eb0dd146108a0578063e4098655146108b3578063f340fa01146108d0578063f9f447eb146108e0578063fc300522146108fd578063fcf369181461091a575b61041b61097133345b600160a060020a0382166000908152602081905260409020548082011015610a1057610a105b600080600181548110156100025750508052565b61097360043560008181526002602090815260408083206007909252822060038101545b6002830154600014801590610bd057506002830154610bd090825b6000828152600260205260408120815b508054600090815260076020526040902060038101548414156118195760019250611763565b6109736004355b600081815260076020526040812060068101543a45810291849161161d9190610889565b6109736004356000818152600760205260409020600801545b919050565b610985600435600081815260076020526040902054600160a060020a03166102e9565b6109736009545b90565b610973600a54610318565b6109736004356000818152600760205260409020600301546102e9565b61041b5b6001546000908190811415610c7b57610a2f565b6109736004356000818152600760205260409020600c015460c860020a900460ff166102e9565b61041b600435600160a060020a033316600090815260208190526040902054819010610a3357610a363382610a9f565b61097360043560008181526007602052604090206004015460ff166102e9565b60408051600435600160a060020a03908116606060020a9081028352339190911602601482015281519081900360280190206000908152600560205220805460ff191660011790555b005b610973600654610318565b61097360015481565b61041b60043560243560443560643560843560a4356000600061164533898989898989610472565b61097360043560243560443560643560843560a43560c4355b60408051600160a060020a03988916606060020a90810282529790981690960260148801526028870194909452602c860192909252604c85015260ff1660f860020a02606c840152606d8301525190819003608d01902090565b610985600454600160a060020a0316610318565b61041b60043560008181526007602052604090206001810154600160a060020a039081163391909116146116df57610a2f565b610985600c54600160a060020a0316610318565b6109736004356024355b60408051600160a060020a03848116606060020a9081028352908416026014820152815190819003602801902060009081526005602052205460ff165b92915050565b61097360043560006020819052908152604090205481565b6109736004356000818152600760205260409020600c015460d060020a900460ff166102e9565b6109a26004355b6040805160208181018352600080835284815260078252838120600d01548152600b825283902080548451601f8201849004840281018401909552808552929392909183018282801561063257820191906000526020600020905b81548152906001019060200180831161061557829003601f168201915b505050505090506102e9565b6109736004356000818152600760205260409020600601546102e9565b610973600435600081815260076020819052604090912001546102e9565b610985600435600081815260076020526040902060010154600160a060020a03166102e9565b6109736004356000818152600260205260409020600101546102e9565b610985600354600160a060020a0316610318565b60408051600435600160a060020a03908116606060020a9081028352339190911602601482015281519081900360280190206000908152600560205220805460ff1916905561041b565b6109736004356000818152600760205260409020600a01546102e9565b6109736004356000818152600760205260409020600c015460c060020a900460ff166102e9565b6109736004355b6001546000908190811415610af657610adc565b6109a2604080516020818101835260008252825160088054601f810184900484028301840190955284825292939092918301828280156107de57820191906000526020600020905b8154815290600101906020018083116107c157829003601f168201915b50505050509050610318565b61041b6000806004361115610de05760046000369050038281815481835581811511610d3e57601f016020900481601f01602090048360005260206000209182019101610d3e9190610dc3565b610973600435600081815260026020819052604090912001546102e9565b6109736004356000818152600760205260409020600c015460a060020a900460e060020a026102e9565b6109736004356024355b60008282111561163057818360640204905061056e565b61097360043560006000610ae283610765565b6109736004356000818152600760205260409020600201546102e9565b61041b600435610a3381346101f6565b6109736004356000818152600760205260409020600d01546102e9565b6109736004356000818152600760205260409020600b01546102e9565b61041b60043560006000600060006000602060405190810160405280600081526020015060005a888252600760205260408220600c810154919850965060c860020a900460ff161561100d575b5050505050505050565b565b60408051918252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b60405180806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f168015610a025780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b600160a060020a03821660009081526020819052604090208054820190555b5050565b50565b604051600160a060020a03331690600090839082818181858883f193505050501515610a335733600160a060020a03165a60405183906000818181858888f193505050501515610a3357610a3361021c565b600187015490925061131690600160a060020a0316865b600160a060020a03821660009081526020819052604090205481111561173b5761173b61021c565b60008181526007602052604090206003015491505b50919050565b90506000811415610ac75760009150610adc565b5060015460009081526002602052604090205b8054610b31908460008281526002602052604081206001810154829081141561176b57611763565b15610b4d57600101546000908152600260205260409020610b09565b8054610b769084600082815260026020819052604082209081015482908114156117df57611763565b15610b9557600290810154600090815260209190915260409020610b09565b805460009081526007602052604090206003015483901015610bba5760009150610adc565b80549150610adc565b600093505b505050919050565b15610c0d5760029283015460009081526020938452604080822080548352600790955290206003810154909250811415610c2c5782549350610bc8565b6001830154600014801590610c3157506001830154610c31908261026f565b610254565b15610bc3576001929092015460009081526002602090815260408083208054845260079092529091206003810154919390925090811415610c2c5782600001600050549350610bc8565b5050600154600090815260026020908152604080832060079092529091206003015443811015610a2f575b610cc2600154600090819081141561194e57610ddc565b610a2f565b15610cbd57610d3960018054600090815260026020819052604080832091820180548452908320908390558054845592830180548254909155909291818114611007576002600050600083815260200190815260200160002060005090506000600102816000016000508190555061100782610fe1565b610ca6565b50505050600090505b8154811015610de05760003682810360001901908110156100025790013560f860020a900460f860020a0282826001855403038154811015610002579060005260206000209060209182820401919006601f036101000a81548160ff0219169060f860020a84040217905550600101610d47565b50610e879291505b80821115610ddc5760008155600101610dc3565b600191505b5090565b81600b600050600084604051808280548015610e1857820191906000526020600020905b815481529060010190602001808311610e04575b50509150506040518091039020815260200190815260200160002060005090805482805482825590600052602060002090601f01602090048101928215610dbb57600052602060002091601f016020900482015b82811115610dbb578254825591600101919060010190610e6c565b505081604051808280548015610eb957820191906000526020600020905b815481529060010190602001808311610ea5575b5050604051908190039020600a5550508154600981905560088054828255600082905290916020601f92909201919091047ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee39081019190858215610f4557600052602060002091601f016020900482015b82811115610f45578254825591600101919060010190610f2a565b50611007929150610dc3565b6006828155815473ffffffffffffffffffffffffffffffffffffffff199081168a1783556001830180549091163317905560058201849055600c8201805477ffffffff0000000000000000000000000000000000000000191660a060020a60e060020a8b0402179055600d82018790556003820186905560048201805460ff1916861790553a82820155546116d7905b600081815260076020908152604080832060029092528220549091908190841415611895575b50505050565b600c86015460c060020a900460ff161561102657610967565b8554600160a060020a03166000141561103e57610967565b600386015443101561104f57610967565b6003860154600487015460ff160143111561106957610967565b611072886102ac565b6001870154600160a060020a0316600090815260208190526040902054909550859010156110b757600c8601805460c860020a60ff02191660c860020a179055610967565b60408051600c547fa6814e8e0000000000000000000000000000000000000000000000000000000082529151600092600160a060020a031691636595f73a91839163a6814e8e916004828101926020929190829003018189876161da5a03f1156100025750506040805180517f6595f73a0000000000000000000000000000000000000000000000000000000082526004820152905160248281019350602092829003018187876161da5a03f115610002575050506040515111156112e05760408051600c54600389015460048a8101547fe8543d0d0000000000000000000000000000000000000000000000000000000085529084018d9052602484019190915260ff1660448301524360648301529151600160a060020a03929092169163e8543d0d9160848181019260209290919082900301816000876161da5a03f1156100025750505060405151935083600160a060020a0316600014158015611230575033600160a060020a031684600160a060020a031614155b1561123a57610967565b60048660030160005054430304925060008311156112e057604080516003880154600c5460048a8101547f9d12f0f5000000000000000000000000000000000000000000000000000000008552600160a060020a0333811692860192909252602485018e9052604485019390935260ff9290921660648401529251921691639d12f0f591608481810192600092909190829003018183876161da5a03f115610002575050505b3a6007870155600c8601805473ffffffffffffffffffffffffffffffffffffffff191633179055436002870155610a88886105ba565b8554600187015461133391600160a060020a039182169116610531565b1561144457600454600160a060020a031663e8b1d0f3620238c15a038860000160009054906101000a9004600160a060020a031689600c0160149054906101000a900460e060020a02866040518560e060020a0281526004018084600160a060020a03168152602001838152602001806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156113fe5780820380516001836020036101000a031916815260200191505b5094505050505060206040518083038160008887f11561000257505060405151600c8901805460d060020a60ff02191660d060020a9092029190911790555061154b9050565b600354600160a060020a031663e8b1d0f3620238c15a038860000160009054906101000a9004600160a060020a031689600c0160149054906101000a900460e060020a02866040518560e060020a0281526004018084600160a060020a03168152602001838152602001806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f16801561150a5780820380516001836020036101000a031916815260200191505b5094505050505060206040518083038160008887f11561000257505060405151600c8901805460d060020a60ff02191660d060020a90920291909117905550505b600186015461156390600160a060020a0316866101f6565b600c8601805460c860020a60ff02191660c860020a1790556006860154600787015461158f9190610889565b9050620250d15a880301600887018190556007870154026009870181905561271090820260658102829004600a8901819055919004600b880181905560018801546115e792600160a060020a03919091169101610a9f565b6115f83387600a01600050546101f6565b61096773d3cda913deb6f67967b99d67acdfa1712c29360187600b01600050546101f6565b9050612710818302606602049350610bc8565b818360020203836064020460c803905061056e565b91507fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470861415801561168357506000868152600b6020526040812054145b1561168d57610967565b6028430185101561169d57610967565b50600081815260076020526040812080549091600160a060020a0391909116146116c657610967565b60108460ff161015610f5157610967565b610967610347565b600c81015460c860020a900460ff16156116f857610a2f565b600381015443600719919091011161170f57610a2f565b600c01805478ff000000000000000000000000000000000000000000000000191660c060020a17905550565b600160a060020a0382166000908152602081905260409020805482900390555050565b600192505b505092915050565b506000848152600760205260409020600381015484901161178f5760009250611763565b60018201546117cf9060008181526002602052604081205b6002810154600014156119c35780546000908152600760205260409020600301549150610adc565b84111561175e5760009250611763565b5060008481526007602052604090206003810154849011156118045760009250611763565b600381015484141561175e5760009250611763565b6001820154600014801590611832575060038101548490115b15611852576001919091015460009081526002602052604090209061027f565b600282015460001480159061186b575060038101548490105b1561188c57600291820154600090815260209290925260409091209061027f565b60009250611763565b600154600014156118a65760018490555b600154600090815260026020526040902091505b8154600014156118cc57838255611007565b508054600090815260076020526040902060038181015490840154101561191d5760018201546000141561190257600182018490555b600191909101546000908152600260205260409020906118ba565b60028201546000141561193257600282018490555b60029182015460009081526020929092526040909120906118ba565b506001546000908152600260208190526040822090810154909114156119775760009150610ddc565b60015460009081526007602052604090206003015443901061199c5760009150610ddc565b6002810154600090815260076020526040902060030154439010610dd75760009150610ddc565b6002908101546000908152602091909152604090206117a756606060405260008054600160a060020a0319163317905561014a806100256000396000f300606060405260e060020a6000350463e8b1d0f3811461001b575b005b60806020601f6044356004818101359283018490049093028401604052606082815261009e949335936024803594606494909101918190838280828437509495505050505050600080543373ffffffffffffffffffffffffffffffffffffffff9081169116146100b0576100b06000806001815481101561000257505080805250565b60408051918252519081900360200190f35b8373ffffffffffffffffffffffffffffffffffffffff168360e060020a9004836040518260e060020a028152600401808280519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156101295780820380516001836020036101000a031916815260200191505b509150506000604051808303816000876161da5a03f197965050505050505056606060405260008054600160a060020a0319908116331780835560018054909216600160a060020a03909116179055610d5290819061003e90396000f300606060405236156100e55760e060020a600035046319f74e1f811461012957806323306ed614610147578063299179541461015257806350a3bd391461015e5780635ae348681461016a5780636595f73a14610175578063741b3c391461019057806384c92c9a146101985780638dd5e298146101ad578063910789c4146101bf5780639d12f0f5146101fc578063a6814e8e1461023e578063aec918c71461024d578063b010d94a1461026d578063bc966ddc14610282578063c3daab961461028d578063c4afc3fb1461029c578063c861cd66146102b7578063e8543d0d146102cf575b6103135b61031533345b600160a060020a0382166000908152600260205260409020548082011015610346576103465b600080600181548110156100025750508052565b6103176004356024355b600060006000836000141561075957610751565b6103175b3a45025b90565b6103136108ca33610274565b61031361088e336101b4565b61031761020061014f565b6103176004356000818152600460205260409020545b919050565b6103136100e9565b6103176004355b600061072e33610740610242565b6103176004355b60006107c98261019f565b61031760043560038054829081101561000257506000527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b015481565b61031360043560243560443560643560008054819081908190819081908190600160a060020a039081163391909116146104cc575b5050505050505050505050565b6103175b60006106d243610254565b6103176004355b6000600060006003600050546000141561066a57610663565b6103176004355b600061083d82610740610242565b61031761010061014f565b6103136004356103683361019f565b6103175b60006000600360005054600014156106e2576106de565b61031760043560026020526000908152604090205481565b610329600435602435604435606435600060006000600060006000888710806102fc57508760ff16890187115b1561044357600095505b5050505050949350505050565b005b565b60408051918252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b600160a060020a03821660009081526002602052604090208054820190555050565b156103c357600160a060020a03331660009081526002602052604090205481111561039557610395610115565b61039d61014b565b600160a060020a03331660009081526002602052604090205482900310156103c3575b50565b6103f133825b600160a060020a0382166000908152600260205260409020548111156108f3576108f3610115565b604051600160a060020a03331690600090839082818181858883f1935050505015156103c05733600160a060020a03165a60405183906000818181858888f1935050505015156103c0576103c0610115565b61044c89610254565b945084600014156104605760009550610306565b6000858152600460208190526040909120945060ff89811682900416935089880304915060028201839011156104995760009550610306565b508254808a069084908284018190069081101561000257600091825260209091200154600160a060020a03169550610306565b6104d589610254565b600081815260046020819052604090912091985090965060ff898116829004169250438a9003049050600281018290111561054d57600094505b8554851015610231578a600160a060020a03168686815481101561000257600091825260209091200154600160a060020a0316141561056b5761055f565b6002865410156105a157610231565b93505b6001949094019361050f565b8585815481101561000257600091825260209091200154600160a060020a0316925061055c838c5b60006000600061091661014b565b600094505b8554851015610231578a600160a060020a03168686815481101561000257600091825260209091200154600160a060020a0316141561061157858654600188548801030681548110156100025760206000200154600160a060020a0316935061061d9050838c610593565b600194909401936105a6565b93506106276102a0565b6000141561063d5761063d5b600061095c6102a0565b610231836106496102a0565b600060008260001415610b6857610b68610115565b600092505b5050919050565b600091505b60035482101561065e57600380548381036000190190811015610002576000919091527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b015490508381116106c657809250610663565b6001919091019061066f565b905061014f565b600091505b5090565b60038054600019810190811015610002576000919091527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b01549050438111156106d9578091506106de565b806107455750610745336107406102a0565b610133565b905061018b565b600092505b505092915050565b60008481526004602052604081208054909350141561077b5760009250610751565b5060005b815481101561074c5784600160a060020a03168282815481101561000257600091825260209091200154600160a060020a031614156107c15760019250610751565b60010161077f565b156107d65750600061018b565b6107de6102a0565b6000141580156107f957506101006107f46102a0565b034310155b156108065750600061018b565b61080e61014b565b600160a060020a03831660009081526002602052604090205410156108355750600061018b565b50600161018b565b151561084b5750600061018b565b6108536102a0565b600014610835576101006108656102a0565b0343106108745750600061018b565b610880826107406102a0565b15156108355750600061018b565b156103155761089b6102a0565b600014156108ab576108ab610633565b610315336108b76102a0565b60008160001415610b1557610b15610115565b15610315576108d76102a0565b600014156108e7576108e7610633565b610315336106496102a0565b600160a060020a0382166000908152600260205260409020805482900390555050565b600160a060020a038616600090815260026020526040902054909250905080821115610940579050805b61094a85836103c9565b61095484836100ef565b819250610751565b60001461096b5761096b610115565b5061020043016004600061097d610242565b815260208181019290925260409081016000908120848252600484529181208254815481835582845294909220909381019282156109dc5760005260206000209182015b828111156109dc5782548255916001019190600101906109c1565b50610a029291505b808211156106de578054600160a060020a03191681556001016109e4565b5050610a4f8160008181526004602052604081209080805b8354811015610c9a578354604080514340815260208101849052815190819003909101902006925082811415610ca157610d4a565b6003805460018101808355919082908015829011610a9057818360005260206000209182019101610a9091905b808211156106de5760008155600101610a7c565b505060038054849350909150600019810190811015610002575080546000919091527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85a015550565b50505050828160018354038154811015610002575050815460008381526020902001600019018054600160a060020a03191690911790555b505050565b610b1f8383610133565b15610b2957610b10565b50600081815260046020526040902080546001810180835590829082908015829011610ad857818360005260206000209182019101610ad89190610a7c565b610b728484610133565b1515610b7d57610c8c565b6000838152600460205260409020805490925060011415610bc75760008281815481835581811511610bc257818360005260206000209182019101610bc29190610a7c565b505050505b5060005b8154811015610c8c5783600160a060020a03168282815481101561000257600091825260209091200154600160a060020a03161415610c9257816001835403815481101561000257906000526020600020900160009054906101000a9004600160a060020a031682828154811015610002576020600020018054600160a060020a031916909217909155508154600019810180845590839082908015829011610c8757818360005260206000209182019101610c879190610a7c565b505050505b50505050565b600101610bcb565b5050505050565b8381815481101561000257508054600082815260209020830154600160a060020a03169350849081101561000257906000526020600020900160009054906101000a9004600160a060020a0316848281548110156100025750602060002083018054600160a060020a03191690921790915550835482908590859081101561000257906000526020600020900160006101000a815481600160a060020a03021916908302179055505b600101610a1a56",
        "info": {
            "abiDefinition": [
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getNextCallSibling",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallMaxCost",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallGasUsed",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallContractAddress",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "getLastDataLength",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "getLastDataHash",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallTargetBlock",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "rotateTree",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "checkIfCalled",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "value",
                            "type": "uint256"
                        }
                    ],
                    "name": "withdraw",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallGracePeriod",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "schedulerAddress",
                            "type": "address"
                        }
                    ],
                    "name": "addAuthorization",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "getLastCallKey",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [],
                    "name": "rootNodeCallKey",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "contractAddress",
                            "type": "address"
                        },
                        {
                            "name": "abiSignature",
                            "type": "bytes4"
                        },
                        {
                            "name": "dataHash",
                            "type": "bytes32"
                        },
                        {
                            "name": "targetBlock",
                            "type": "uint256"
                        },
                        {
                            "name": "gracePeriod",
                            "type": "uint8"
                        },
                        {
                            "name": "nonce",
                            "type": "uint256"
                        }
                    ],
                    "name": "scheduleCall",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "scheduledBy",
                            "type": "address"
                        },
                        {
                            "name": "contractAddress",
                            "type": "address"
                        },
                        {
                            "name": "abiSignature",
                            "type": "bytes4"
                        },
                        {
                            "name": "dataHash",
                            "type": "bytes32"
                        },
                        {
                            "name": "targetBlock",
                            "type": "uint256"
                        },
                        {
                            "name": "gracePeriod",
                            "type": "uint8"
                        },
                        {
                            "name": "nonce",
                            "type": "uint256"
                        }
                    ],
                    "name": "getCallKey",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "authorizedAddress",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "cancelCall",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "getCallerPoolAddress",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "schedulerAddress",
                            "type": "address"
                        },
                        {
                            "name": "contractAddress",
                            "type": "address"
                        }
                    ],
                    "name": "checkAuthorization",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "name": "accountBalances",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "checkIfSuccess",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallData",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallBaseGasPrice",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallGasPrice",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallScheduledBy",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallLeftChild",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "unauthorizedAddress",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "schedulerAddress",
                            "type": "address"
                        }
                    ],
                    "name": "removeAuthorization",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallPayout",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "checkIfCancelled",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "blockNumber",
                            "type": "uint256"
                        }
                    ],
                    "name": "getNextCallKey",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "getLastData",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "registerData",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallRightChild",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallABISignature",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes4"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "baseGasPrice",
                            "type": "uint256"
                        },
                        {
                            "name": "gasPrice",
                            "type": "uint256"
                        }
                    ],
                    "name": "getCallFeeScalar",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "blockNumber",
                            "type": "uint256"
                        }
                    ],
                    "name": "getNextBlockWithCall",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallCalledAtBlock",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "accountAddress",
                            "type": "address"
                        }
                    ],
                    "name": "deposit",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallDataHash",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bytes32"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "getCallFee",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        }
                    ],
                    "name": "doCall",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "inputs": [],
                    "type": "constructor"
                }
            ],
            "compilerVersion": "0.1.1-ed7a8a35",
            "developerDoc": {
                "methods": {}
            },
            "language": "Solidity",
            "languageVersion": "0",
            "source": "contract Relay {\n        address operator;\n\n        function Relay() {\n                operator = msg.sender;\n        }\n\n        function relayCall(address contractAddress, bytes4 abiSignature, bytes data) public returns (bool) {\n                if (msg.sender != operator) {\n                        __throw();\n                }\n                return contractAddress.call(abiSignature, data);\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n\n\ncontract CallerPoolAlarmAPI {\n        /*\n         *  Abstract contract for the caller pool to be able to access the\n         *  Alarm api.\n         */\n        function getCallGracePeriod(bytes32 callKey) public returns (uint);\n        function getCallTargetBlock(bytes32 callKey) public returns (uint);\n}\n\n\ncontract CallerPool {\n        address operator;\n        CallerPoolAlarmAPI alarm;\n\n        function CallerPool() {\n                operator = msg.sender;\n                alarm = CallerPoolAlarmAPI(operator);\n        }\n\n        /*\n         *  Caller bonding\n         */\n        mapping (address => uint) public callerBonds;\n\n        function getMinimumBond() public returns (uint) {\n                return tx.gasprice * block.gaslimit;\n        }\n\n        function _deductFromBond(address callerAddress, uint value) internal {\n                /*\n                 *  deduct funds from a bond value without risk of an\n                 *  underflow.\n                 */\n                if (value > callerBonds[callerAddress]) {\n                        // Prevent Underflow.\n                        __throw();\n                }\n                callerBonds[callerAddress] -= value;\n        }\n\n        function _addToBond(address callerAddress, uint value) internal {\n                /*\n                 *  Add funds to a bond value without risk of an\n                 *  overflow.\n                 */\n                if (callerBonds[callerAddress] + value < callerBonds[callerAddress]) {\n                        // Prevent Overflow\n                        __throw();\n                }\n                callerBonds[callerAddress] += value;\n        }\n\n        function depositBond() public {\n                _addToBond(msg.sender, msg.value);\n        }\n\n        function withdrawBond(uint value) public {\n                /*\n                 *  Only if you are not in either of the current call pools.\n                 */\n                if (isInAnyPool(msg.sender)) {\n                        // Prevent underflow\n                        if (value > callerBonds[msg.sender]) {\n                                __throw();\n                        }\n                        // Don't allow withdrawl if this would drop the bond\n                        // balance below the minimum.\n                        if (callerBonds[msg.sender] - value < getMinimumBond()) {\n                                return;\n                        }\n                }\n                _deductFromBond(msg.sender, value);\n                if (!msg.sender.send(value)) {\n                        // Potentially sending money to a contract that\n                        // has a fallback function.  So instead, try\n                        // tranferring the funds with the call api.\n                        if (!msg.sender.call.gas(msg.gas).value(value)()) {\n                                // Revert the entire transaction.  No\n                                // need to destroy the funds.\n                                __throw();\n                        }\n                }\n        }\n\n        function() {\n                /*\n                 *  Fallback function that allows depositing bond funds just by\n                 *  sending a transaction.\n                 */\n                _addToBond(msg.sender, msg.value);\n        }\n\n        /*\n         *  API used by Alarm service\n         */\n        function getDesignatedCaller(bytes32 callKey, uint targetBlock, uint8 gracePeriod, uint blockNumber) public returns (address) {\n                /*\n                 *  Returns the caller from the current call pool who is\n                 *  designated as the executor of this call.\n                 */\n                if (blockNumber < targetBlock || blockNumber > targetBlock + gracePeriod) {\n                        // blockNumber not within call window.\n                        return 0x0;\n                }\n\n                // Pool used is based on the starting block for the call.  This\n                // allows us to know that the pool cannot change for at least\n                // POOL_FREEZE_NUM_BLOCKS which is kept greater than the max\n                // grace period.\n                uint poolNumber = getPoolKeyForBlock(targetBlock);\n                if (poolNumber == 0) {\n                        // No pool currently in operation.\n                        return 0x0;\n                }\n                var pool = callerPools[poolNumber];\n\n                uint numWindows = gracePeriod / 4;\n                uint blockWindow = (blockNumber - targetBlock) / 4;\n\n                if (blockWindow + 2 > numWindows) {\n                        // We are within the free-for-all period.\n                        return 0x0;\n                }\n\n                uint offset = uint(callKey) % pool.length;\n                return pool[(offset + blockWindow) % pool.length];\n        }\n\n        //event AwardedMissedBlockBonus(address indexed fromCaller, address indexed toCaller, uint indexed poolNumber, bytes32 callKey, uint blockNumber, uint bonusAmount);\n\n        function _doBondBonusTransfer(address fromCaller, address toCaller) internal returns (uint) {\n                uint bonusAmount = getMinimumBond();\n                uint bondBalance = callerBonds[fromCaller];\n\n                // If the bond balance is lower than the award\n                // balance, then adjust the reward amount to\n                // match the bond balance.\n                if (bonusAmount > bondBalance) {\n                        bonusAmount = bondBalance;\n                }\n\n                // Transfer the funds fromCaller => toCaller\n                _deductFromBond(fromCaller, bonusAmount);\n                _addToBond(toCaller, bonusAmount);\n\n                return bonusAmount;\n        }\n\n        function awardMissedBlockBonus(address toCaller, bytes32 callKey, uint targetBlock, uint8 gracePeriod) public {\n                if (msg.sender != operator) {\n                        return;\n                }\n\n                uint poolNumber = getPoolKeyForBlock(targetBlock);\n                var pool = callerPools[poolNumber];\n                uint i;\n                uint bonusAmount;\n                address fromCaller;\n\n                uint numWindows = gracePeriod / 4;\n                uint blockWindow = (block.number - targetBlock) / 4;\n\n                // Check if we are within the free-for-all period.  If so, we\n                // award from all pool members.\n                if (blockWindow + 2 > numWindows) {\n                        for (i = 0; i < pool.length; i++) {\n                                if (pool[i] == toCaller) {\n                                        continue;\n                                }\n                                fromCaller = pool[i];\n                                bonusAmount = _doBondBonusTransfer(fromCaller, toCaller);\n\n                                // Log the bonus was awarded.\n                                //AwardedMissedBlockBonus(fromCaller, toCaller, poolNumber, callKey, block.number, bonusAmount);\n                        }\n                        return;\n                }\n\n                // Special case for single member and empty pools\n                if (pool.length < 2) {\n                        return;\n                }\n\n                // Otherwise the award comes from the previous caller.\n                for (i = 0; i < pool.length; i++) {\n                        // Find where the member is in the pool and\n                        // award from the previous pool members bond.\n                        if (pool[i] == toCaller) {\n                                fromCaller = pool[(i + pool.length - 1) % pool.length];\n\n                                bonusAmount = _doBondBonusTransfer(fromCaller, toCaller);\n\n                                // Log the bonus was awarded.\n                                //AwardedMissedBlockBonus(fromCaller, toCaller, poolNumber, callKey, block.number, bonusAmount);\n\n                                // Remove the caller from the next pool.\n                                if (getNextPoolKey() == 0) {\n                                        // This is the first address to modify the\n                                        // current pool so we need to setup the next\n                                        // pool.\n                                        _initiateNextPool();\n                                }\n                                _removeFromPool(fromCaller, getNextPoolKey());\n                                return;\n                        }\n                }\n        }\n\n        /*\n         *  Caller Pool Management\n         */\n        uint[] public poolHistory;\n        mapping (uint => address[]) callerPools;\n\n        function getPoolKeyForBlock(uint blockNumber) public returns (uint) {\n                if (poolHistory.length == 0) {\n                        return 0;\n                }\n                for (uint i = 0; i < poolHistory.length; i++) {\n                        uint poolStartBlock = poolHistory[poolHistory.length - i - 1];\n                        if (poolStartBlock <= blockNumber) {\n                                return poolStartBlock;\n                        }\n                }\n                return 0;\n        }\n\n        function getActivePoolKey() public returns (uint) {\n                return getPoolKeyForBlock(block.number);\n        }\n\n        function getPoolSize(uint poolKey) returns (uint) {\n                return callerPools[poolKey].length;\n        }\n\n        function getNextPoolKey() public returns (uint) {\n                if (poolHistory.length == 0) {\n                        return 0;\n                }\n                uint latestPool = poolHistory[poolHistory.length - 1];\n                if (latestPool > block.number) {\n                        return latestPool;\n                }\n                return 0;\n        }\n\n        function isInAnyPool(address callerAddress) public returns (bool) {\n                /*\n                 *  Returns boolean whether the `callerAddress` is in either\n                 *  the current active pool or the next pool.\n                 */\n                return isInPool(msg.sender, getActivePoolKey()) || isInPool(msg.sender, getNextPoolKey());\n        }\n\n        function isInPool(address callerAddress, uint poolNumber) public returns (bool) {\n                /*\n                 *  Returns boolean whether the `callerAddress` is in the\n                 *  poolNumber.\n                 */\n                if (poolNumber == 0 ) {\n                        // Nobody can be in pool 0\n                        return false;\n                }\n\n                var pool = callerPools[poolNumber];\n\n                // Nobody is in the pool.\n                if (pool.length == 0) {\n                        return false;\n                }\n\n                for (uint i = 0; i < pool.length; i++) {\n                        // Address is in the pool and thus is allowed to exit.\n                        if (pool[i] == callerAddress) {\n                                return true;\n                        }\n                }\n\n                return false;\n        }\n\n        // Ten minutes into the future.\n        uint constant POOL_FREEZE_NUM_BLOCKS = 256;\n        //uint constant POOL_FREEZE_NUM_BLOCKS = 40;\n\n        function getPoolFreezeDuration() public returns (uint) {\n                return POOL_FREEZE_NUM_BLOCKS;\n        }\n\n        function getPoolMinimumLength() public returns (uint) {\n                return 2 * POOL_FREEZE_NUM_BLOCKS;\n        }\n\n        function canEnterPool(address callerAddress) public returns (bool) {\n                /*\n                 *  Returns boolean whether `callerAddress` is allowed to enter\n                 *  the next pool (which may or may not already have been\n                 *  created.\n                 */\n                // Not allowed to join if you are in either the current\n                // active pool or the next pool.\n                if (isInAnyPool(callerAddress)) {\n                        return false;\n                }\n\n                // Next pool begins within the POOL_FREEZE_NUM_BLOCKS grace\n                // period so no changes are allowed.\n                if (getNextPoolKey() != 0 && block.number >= (getNextPoolKey() - POOL_FREEZE_NUM_BLOCKS)) {\n                        return false;\n                }\n\n                // Account bond balance is too low.\n                if (callerBonds[callerAddress] < getMinimumBond()) {\n                        return false;\n                }\n                \n                return true;\n        }\n\n        function canExitPool(address callerAddress) public returns (bool) {\n                /*\n                 *  Returns boolean whether `callerAddress` is allowed to exit\n                 *  the current active pool.\n                 */\n                // Can't exit if we aren't in the current active pool.\n                if (!isInPool(callerAddress, getActivePoolKey())) {\n                        return false;\n                }\n\n                // There is a next pool coming up.\n                if (getNextPoolKey() != 0) {\n                        // Next pool begins within the POOL_FREEZE_NUM_BLOCKS\n                        // window and thus can't be modified.\n                        if (block.number >= (getNextPoolKey() - POOL_FREEZE_NUM_BLOCKS)) {\n                                return false;\n                        }\n\n                        // Next pool was already setup and callerAddress isn't\n                        // in it which indicates that they already left.\n                        if (!isInPool(callerAddress, getNextPoolKey())) {\n                                return false;\n                        }\n                }\n\n                // They must be in the current pool and either the next pool\n                // hasn't been initiated or it has but this user hasn't left\n                // yet.\n                return true;\n        }\n\n        function _initiateNextPool() internal {\n                if (getNextPoolKey() != 0) {\n                        // If there is already a next pool, we shouldn't\n                        // initiate a new one until it has become active.\n                        __throw();\n                }\n                // Set the next pool to start at double the freeze block number\n                // in the future.\n                uint nextPool = block.number + 2 * POOL_FREEZE_NUM_BLOCKS;\n\n                // Copy the current pool into the next pool.\n                callerPools[nextPool] = callerPools[getActivePoolKey()];\n\n                // Randomize the pool order\n                _shufflePool(nextPool);\n\n                // Push the next pool into the pool history.\n                poolHistory.length += 1;\n                poolHistory[poolHistory.length - 1] = nextPool;\n        }\n\n        function _shufflePool(uint poolNumber) internal {\n                var pool = callerPools[poolNumber];\n\n                uint swapIndex;\n                address buffer;\n\n                for (uint i = 0; i < pool.length; i++) {\n                        swapIndex = uint(sha3(block.blockhash(block.number), i)) % pool.length;\n                        if (swapIndex == i) {\n                                continue;\n                        }\n                        buffer = pool[i];\n                        pool[i] = pool[swapIndex];\n                        pool[swapIndex] = buffer;\n                }\n        }\n\n        //event AddedToPool(address indexed callerAddress, uint indexed pool);\n        //event RemovedFromPool(address indexed callerAddress, uint indexed pool);\n\n        function _addToPool(address callerAddress, uint poolNumber) internal {\n                if (poolNumber == 0 ) {\n                        // This shouldn't be called with 0;\n                        __throw();\n                }\n\n                // already in the pool.\n                if (isInPool(callerAddress, poolNumber)) {\n                        return;\n                }\n                var pool = callerPools[poolNumber];\n                pool.length += 1;\n                pool[pool.length - 1] = callerAddress;\n                \n                // Log the addition.\n                //AddedToPool(callerAddress, poolNumber);\n        }\n\n        function _removeFromPool(address callerAddress, uint poolNumber) internal {\n                if (poolNumber == 0 ) {\n                        // This shouldn't be called with 0;\n                        __throw();\n                }\n\n                // nothing to remove.\n                if (!isInPool(callerAddress, poolNumber)) {\n                        return;\n                }\n                var pool = callerPools[poolNumber];\n                // special case length == 1\n                if (pool.length == 1) {\n                        pool.length = 0;\n                }\n                for (uint i = 0; i < pool.length; i++) {\n                        // When we find the index of the address to remove we\n                        // shift the last person to that location and then we\n                        // truncate the last member off of the end.\n                        if (pool[i] == callerAddress) {\n                                pool[i] = pool[pool.length - 1];\n                                pool.length -= 1;\n                                break;\n                        }\n                }\n\n                // Log the addition.\n                //RemovedFromPool(callerAddress, poolNumber);\n        }\n\n        function enterPool() public {\n                /*\n                 *  Request to be added to the call pool.\n                 */\n                if (canEnterPool(msg.sender)) {\n                        if (getNextPoolKey() == 0) {\n                                // This is the first address to modify the\n                                // current pool so we need to setup the next\n                                // pool.\n                                _initiateNextPool();\n                        }\n                        _addToPool(msg.sender, getNextPoolKey());\n                }\n        }\n\n        function exitPool() public {\n                /*\n                 *  Request to be removed from the call pool.\n                 */\n                if (canExitPool(msg.sender)) {\n                        if (getNextPoolKey() == 0) {\n                                // This is the first address to modify the\n                                // current pool so we need to setup the next\n                                // pool.\n                                _initiateNextPool();\n                        }\n                        _removeFromPool(msg.sender, getNextPoolKey());\n                }\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n\n\ncontract Alarm {\n        /*\n         *  Administration API\n         *\n         *  There is currently no special administrative API beyond the hard\n         *  coded owner address which receives 1% of each executed call.  This\n         *  eliminates any need for trust as nobody has any special access.\n         */\n        function Alarm() {\n                unauthorizedRelay = new Relay();\n                authorizedRelay = new Relay();\n                callerPool = new CallerPool();\n        }\n\n        address constant owner = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\n\n        /*\n         *  Account Management API\n         */\n        mapping (address => uint) public accountBalances;\n\n        function _deductFunds(address accountAddress, uint value) internal {\n                /*\n                 *  Helper function that should be used for any reduction of\n                 *  account funds.  It has error checking to prevent\n                 *  underflowing the account balance which would be REALLY bad.\n                 */\n                if (value > accountBalances[accountAddress]) {\n                        // Prevent Underflow.\n                        __throw();\n                }\n                accountBalances[accountAddress] -= value;\n        }\n\n        function _addFunds(address accountAddress, uint value) internal {\n                /*\n                 *  Helper function that should be used for any addition of\n                 *  account funds.  It has error checking to prevent\n                 *  overflowing the account balance.\n                 */\n                if (accountBalances[accountAddress] + value < accountBalances[accountAddress]) {\n                        // Prevent Overflow.\n                        __throw();\n                }\n                accountBalances[accountAddress] += value;\n        }\n\n        //event Deposit(address indexed _from, address indexed accountAddress, uint value);\n\n        function deposit(address accountAddress) public {\n                /*\n                 *  Public API for depositing funds in a specified account.\n                 */\n                _addFunds(accountAddress, msg.value);\n                //Deposit(msg.sender, accountAddress, msg.value);\n        }\n\n        //event Withdraw(address indexed accountAddress, uint value);\n\n        function withdraw(uint value) public {\n                /*\n                 *  Public API for withdrawing funds.\n                 */\n                if (accountBalances[msg.sender] >= value) {\n                        _deductFunds(msg.sender, value);\n                        if (!msg.sender.send(value)) {\n                                // Potentially sending money to a contract that\n                                // has a fallback function.  So instead, try\n                                // tranferring the funds with the call api.\n                                if (!msg.sender.call.gas(msg.gas).value(value)()) {\n                                        // Revert the entire transaction.  No\n                                        // need to destroy the funds.\n                                        __throw();\n                                }\n                        }\n                        //Withdraw(msg.sender, value);\n                }\n        }\n\n        function() {\n                /*\n                 *  Fallback function that allows depositing funds just by\n                 *  sending a transaction.\n                 */\n                _addFunds(msg.sender, msg.value);\n                //Deposit(msg.sender, msg.sender, msg.value);\n        }\n\n        /*\n         *  Call tracking API\n         */\n        struct Node {\n                bytes32 callKey;\n                bytes32 left;\n                bytes32 right;\n        }\n\n        bytes32 public rootNodeCallKey;\n\n        mapping (bytes32 => Node) call_to_node;\n\n        function _getTreeMaxBlock(bytes32 callKey) internal returns (uint) {\n                /*\n                 *  Returns the greatest block number for all calls in the\n                 *  section of the call tree denoted by callKey.\n                 */\n                Node currentNode = call_to_node[callKey];\n\n                while (true) {\n                        if (currentNode.right == 0x0) {\n                                return key_to_calls[currentNode.callKey].targetBlock;\n                        }\n\n                        currentNode = call_to_node[currentNode.right];\n                }\n        }\n\n        function _shouldGoLeft(bytes32 callKey, uint blockNumber) internal returns (bool) {\n                /*\n                 * not if left is empty\n                 * not if current node was already called\n                 * not if current node is in the past or current block.\n                 * not if left node is in the past.\n                 */\n                Node currentNode = call_to_node[callKey];\n\n                // Nowhere to go.\n                if (currentNode.left == 0x0) {\n                        return false;\n                }\n\n                Call currentCall = key_to_calls[callKey];\n\n                // Current call is already in the past or is up next.\n                if (currentCall.targetBlock <= blockNumber) {\n                        return false;\n                }\n\n                // Left call is in the past\n                if (blockNumber > _getTreeMaxBlock(currentNode.left)) {\n                        return false;\n                }\n\n                return true;\n        }\n\n        function _shouldGoRight(bytes32 callKey, uint blockNumber) internal returns (bool) {\n                /*\n                 * not if right is empty.\n                 * not if current node is already in the future.\n                 * not if current node is equal to targetBlock and it isn't already called.\n                 *\n                 */\n                Node currentNode = call_to_node[callKey];\n\n                // Nowhere to go.\n                if (currentNode.right == 0x0) {\n                        return false;\n                }\n\n                Call currentCall = key_to_calls[callKey];\n\n                // Current call is already in the future\n                if (currentCall.targetBlock > blockNumber) {\n                        return false;\n                }\n\n                // Current call equals the desired block number and has not\n                // been called yet and is not cancelled.\n                if (currentCall.targetBlock == blockNumber) {\n                        return false;\n                }\n\n                return true;\n        }\n\n        function getNextBlockWithCall(uint blockNumber) public returns (uint) {\n                bytes32 nextCallKey = getNextCallKey(blockNumber);\n                if (nextCallKey == 0x0) {\n                        return 0;\n                }\n                return key_to_calls[nextCallKey].targetBlock;\n        }\n\n        function getNextCallKey(uint blockNumber) public returns (bytes32) {\n                if (rootNodeCallKey == 0x0) {\n                        // No calls registered\n                        return 0x0;\n                }\n\n                Node currentNode = call_to_node[rootNodeCallKey];\n\n                while (true) {\n                        if (_shouldGoLeft(currentNode.callKey, blockNumber)) {\n                                currentNode = call_to_node[currentNode.left];\n                                continue;\n                        }\n                        if (_shouldGoRight(currentNode.callKey, blockNumber)) {\n                                currentNode = call_to_node[currentNode.right];\n                                continue;\n                        }\n\n                        // Not if it is before the blockNumber\n                        if (key_to_calls[currentNode.callKey].targetBlock < blockNumber) {\n                                return 0x0;\n                        }\n\n                        // Then it must be the next one.\n                        return currentNode.callKey;\n                }\n        }\n\n        function _isBlockNumberInTree(bytes32 callKey, uint blockNumber) internal returns (bool) {\n                var node = call_to_node[callKey];\n\n                while (true) {\n                        var call = key_to_calls[node.callKey];\n\n                        if (call.targetBlock == blockNumber) {\n                                return true;\n                        }\n\n                        if (node.left != 0x0 && call.targetBlock > blockNumber) {\n                                node = call_to_node[node.left];\n                                continue;\n                        }\n\n                        if (node.right != 0x0 && call.targetBlock < blockNumber) {\n                                node = call_to_node[node.right];\n                                continue;\n                        }\n\n                        return false;\n                }\n        }\n\n        function getNextCallSibling(bytes32 callKey) public returns (bytes32) {\n                /*\n                 *  Returns the callKey any subsequent calls that have the same\n                 *  block number as the provided callKey.  If there are no\n                 *  subsequent calls with the same block number returns 0x0\n                 */\n                var node = call_to_node[callKey];\n                var call = key_to_calls[callKey];\n                uint targetBlock = call.targetBlock;\n\n                while (true) {\n                        if (node.right != 0x0 && _isBlockNumberInTree(node.right, targetBlock)) {\n                                node = call_to_node[node.right];\n                                call = key_to_calls[node.callKey];\n                                if (call.targetBlock == targetBlock) {\n                                        return node.callKey;\n                                }\n                                continue;\n                        }\n\n                        if (node.left != 0x0 && _isBlockNumberInTree(node.left, targetBlock)) {\n                                node = call_to_node[node.left];\n                                call = key_to_calls[node.callKey];\n                                if (call.targetBlock == targetBlock) {\n                                        return node.callKey;\n                                }\n                                continue;\n                        }\n\n                        return 0x0;\n                }\n        }\n\n        function getCallLeftChild(bytes32 callKey) public returns (bytes32) {\n                return call_to_node[callKey].left;\n        }\n\n        function getCallRightChild(bytes32 callKey) public returns (bytes32) {\n                return call_to_node[callKey].right;\n        }\n\n        //event CallPlacedInTree(bytes32 indexed callKey);\n\n        function placeCallInTree(bytes32 callKey) internal {\n                /*\n                 * Calls are stored in a tree structure.  Each tree node\n                 * represents a single call.  Nodes have a left and right\n                 * child.  The left child represents a call that should happen\n                 * before the node.  The right child represents a call that\n                 * should happen after the node.\n                 */\n                Call targetCall = key_to_calls[callKey];\n\n                if (callKey == call_to_node[callKey].callKey) {\n                        // This call key is already placed in the tree.\n                        return;\n                }\n\n                if (rootNodeCallKey == 0x0) {\n                        // This is the first call placement and thus should be\n                        // set as the root node.\n                        rootNodeCallKey = callKey;\n                }\n\n                Node currentNode = call_to_node[rootNodeCallKey];\n\n                while (true) {\n                        if (currentNode.callKey == 0x0) {\n                                // This is a new node and should be mapped \n                                currentNode.callKey = callKey;\n                                //CallPlacedInTree(callKey);\n                                return;\n                        }\n\n                        Call currentCall = key_to_calls[currentNode.callKey];\n\n                        if (targetCall.targetBlock < currentCall.targetBlock) {\n                                // Call should occure before the current node\n                                // and thus should exist in the left subtree.\n                                if (currentNode.left == 0x0) {\n                                        currentNode.left = callKey;\n                                }\n                                currentNode = call_to_node[currentNode.left];\n                                continue;\n                        }\n\n                        // Call should occur after the current node and thus\n                        // should exist in the right subtree.\n                        if (currentNode.right == 0x0) {\n                                currentNode.right = callKey;\n                        }\n                        currentNode = call_to_node[currentNode.right];\n                }\n        }\n\n        //event TreeRotatedRight(bytes32 indexed oldRootNodeCallKey, bytes32 indexed newRootNodeCallKey);\n\n        //function _rotateRight() internal {\n        //        /*\n        //         *  1. Detatch the left child of the root node.  This is the\n        //         *     new root node.\n        //         *  2. Detatch the right child of the new root node.\n        //         *  3. Set the old root node as the right child of the new root node.\n        //         *  4. Set the detatched right child from the new root node in\n        //         *     the appropriate location in the tree.\n        //         */\n        //        var oldRootNode = call_to_node[rootNodeCallKey];\n        //        var newRootNode = call_to_node[oldRootNode.left];\n        //        // #1\n        //        oldRootNode.left = 0x0;\n        //        rootNodeCallKey = newRootNode.callKey;\n\n        //        // #2\n        //        bytes32 detatchedChildCallKey = newRootNode.right;\n        //        newRootNode.right = 0x0;\n\n        //        // #3\n        //        newRootNode.right = oldRootNode.callKey;\n\n        //        // #4\n        //        if (detatchedChildCallKey != 0x0) {\n        //                // First reset the node to not have a callKey,\n        //                // otherwise the call to `placeCallInTree` will exit\n        //                // early thinking this node is already placed.\n        //                var detatchedChildNode = call_to_node[detatchedChildCallKey];\n        //                detatchedChildNode.callKey = 0x0;\n        //                // Now place it at it's new location in the tree.\n        //                placeCallInTree(detatchedChildCallKey);\n        //        }\n\n        //        //TreeRotatedRight(oldRootNode.callKey, newRootNode.callKey);\n        //}\n\n        //function _shouldRotateRight() internal returns (bool) {\n        //        /*\n        //         *  Is the left child of the rootNode in the future of the\n        //         *  current block number.\n        //         */\n        //        if (rootNodeCallKey == 0x0) {\n        //                return false;\n        //        }\n\n        //        var currentRoot = call_to_node[rootNodeCallKey];\n\n        //        // No left child so cant rotate right.\n        //        if (currentRoot.left == 0x0) {\n        //                return false;\n        //        }\n\n        //        // Current root already in the past.\n        //        if (key_to_calls[rootNodeCallKey].targetBlock <= block.number) {\n        //                return false;\n        //        }\n\n        //        return true;\n        //}\n\n        //event TreeRotatedLeft(bytes32 indexed oldRootNodeCallKey, bytes32 indexed newRootNodeCallKey);\n\n        function _rotateLeft() internal {\n                /*\n                 *  1. Detatch the right child of the root node.  This is the\n                 *     new root node.\n                 *  2. Detatch the left child of the new root node.\n                 *  3. Set the old root node as the left child of the new root node.\n                 *  4. Set the detatched left child from the new root node in\n                 *     the appropriate location in the tree.\n                 */\n                var oldRootNode = call_to_node[rootNodeCallKey];\n                var newRootNode = call_to_node[oldRootNode.right];\n                // #1\n                oldRootNode.right = 0x0;\n                rootNodeCallKey = newRootNode.callKey;\n\n                // #2\n                bytes32 detatchedChildCallKey = newRootNode.left;\n\n                // #3\n                newRootNode.left = oldRootNode.callKey;\n\n                // #4\n                if (detatchedChildCallKey != 0x0) {\n                        // First reset the node to not have a callKey,\n                        // otherwise the call to `placeCallInTree` will exit\n                        // early thinking this node is already placed.\n                        var detatchedChildNode = call_to_node[detatchedChildCallKey];\n                        detatchedChildNode.callKey = 0x0;\n                        // Now place it at it's new location in the tree.\n                        placeCallInTree(detatchedChildCallKey);\n                }\n                //TreeRotatedLeft(oldRootNode.callKey, newRootNode.callKey);\n        }\n\n        function _shouldRotateLeft() internal returns (bool) {\n                /*\n                 *  We should rotate left if both the current root node, and\n                 *  its right child are both in the past.\n                 */\n                // Empty call tree.\n                if (rootNodeCallKey == 0x0) {\n                        return false;\n                }\n\n                var currentRoot = call_to_node[rootNodeCallKey];\n\n                // No right child so cant rotate left.\n                if (currentRoot.right == 0x0) {\n                        return false;\n                }\n\n                // Current root already in the future.\n                if (key_to_calls[rootNodeCallKey].targetBlock >= block.number) {\n                        return false;\n                }\n\n                if (key_to_calls[currentRoot.right].targetBlock >= block.number) {\n                        return false;\n                }\n\n                return true;\n        }\n\n        function rotateTree() public {\n                /*\n                 *  Shifts the root node of the tree so that the root node is\n                 *  the tree node prior to the next scheduled call.\n                 */\n                if (rootNodeCallKey == 0x0) {\n                        // No root node (empty tree)\n                        return;\n                }\n\n                var currentRoot = call_to_node[rootNodeCallKey];\n                var rootBlockNumber = key_to_calls[rootNodeCallKey].targetBlock;\n\n                // The current root is in the past so we can potentially rotate\n                // the tree to the left to increase the root block number.\n                if (rootBlockNumber < block.number) {\n                        while (_shouldRotateLeft()) {\n                                _rotateLeft();\n                        }\n                        return;\n                }\n\n                // The current root is in the future so we can potentially\n                // rotate the tree to the right to decrease the root block\n                // number.\n                //if (rootBlockNumber > block.number) {\n                //        while (_shouldRotateRight()) {\n                //                _rotateRight();\n                //        }\n                //}\n        }\n\n        /*\n         *  Scheduling Authorization API\n         */\n        Relay unauthorizedRelay;\n        Relay authorizedRelay;\n\n        function unauthorizedAddress() public returns (address) {\n                return address(unauthorizedRelay);\n        }\n\n        function authorizedAddress() public returns (address) {\n                return address(authorizedRelay);\n        }\n\n        mapping (bytes32 => bool) accountAuthorizations;\n\n        function addAuthorization(address schedulerAddress) public {\n                accountAuthorizations[sha3(schedulerAddress, msg.sender)] = true;\n        }\n\n        function removeAuthorization(address schedulerAddress) public {\n                accountAuthorizations[sha3(schedulerAddress, msg.sender)] = false;\n        }\n\n        function checkAuthorization(address schedulerAddress, address contractAddress) public returns (bool) {\n                return accountAuthorizations[sha3(schedulerAddress, contractAddress)];\n        }\n\n        /*\n         *  Call Information API\n         */\n        bytes32 lastCallKey;\n\n        function getLastCallKey() public returns (bytes32) {\n                return lastCallKey;\n        }\n\n        struct Call {\n                address contractAddress;\n                address scheduledBy;\n                uint calledAtBlock;\n                uint targetBlock;\n                uint8 gracePeriod;\n                uint nonce;\n                uint baseGasPrice;\n                uint gasPrice;\n                uint gasUsed;\n                uint gasCost;\n                uint payout;\n                uint fee;\n                address executedBy;\n                bytes4 abiSignature;\n                bool isCancelled;\n                bool wasCalled;\n                bool wasSuccessful;\n                bytes32 dataHash;\n        }\n\n        mapping (bytes32 => Call) key_to_calls;\n\n        /*\n         *  Getter methods for `Call` information\n         */\n        function getCallContractAddress(bytes32 callKey) public returns (address) {\n                return key_to_calls[callKey].contractAddress;\n        }\n\n        function getCallScheduledBy(bytes32 callKey) public returns (address) {\n                return key_to_calls[callKey].scheduledBy;\n        }\n\n        function getCallCalledAtBlock(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].calledAtBlock;\n        }\n\n        function getCallGracePeriod(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].gracePeriod;\n        }\n\n        function getCallTargetBlock(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].targetBlock;\n        }\n\n        function getCallBaseGasPrice(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].baseGasPrice;\n        }\n\n        function getCallGasPrice(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].gasPrice;\n        }\n\n        function getCallGasUsed(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].gasUsed;\n        }\n\n        function getCallABISignature(bytes32 callKey) public returns (bytes4) {\n                return key_to_calls[callKey].abiSignature;\n        }\n\n        function checkIfCalled(bytes32 callKey) public returns (bool) {\n                return key_to_calls[callKey].wasCalled;\n        }\n\n        function checkIfSuccess(bytes32 callKey) public returns (bool) {\n                return key_to_calls[callKey].wasSuccessful;\n        }\n\n        function checkIfCancelled(bytes32 callKey) public returns (bool) {\n                return key_to_calls[callKey].isCancelled;\n        }\n\n        function getCallDataHash(bytes32 callKey) public returns (bytes32) {\n                return key_to_calls[callKey].dataHash;\n        }\n\n        function getCallPayout(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].payout;\n        }\n\n        function getCallFee(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].fee;\n        }\n\n        /*\n         *  Data Registry API\n         */\n        bytes lastData;\n        uint lastDataLength;\n        bytes32 lastDataHash;\n\n        function getLastDataHash() public returns (bytes32) {\n                return lastDataHash;\n        }\n\n        function getLastDataLength() public returns (uint) {\n                return lastDataLength;\n        }\n\n        function getLastData() public returns (bytes) {\n                return lastData;\n        }\n\n        function getCallData(bytes32 callKey) public returns (bytes) {\n                return hash_to_data[key_to_calls[callKey].dataHash];\n        }\n\n        mapping (bytes32 => bytes) hash_to_data;\n\n        /*\n         *  Data registration API\n         */\n        //event DataRegistered(bytes32 indexed dataHash);\n\n        function registerData() public {\n                bytes trunc;\n                if (msg.data.length > 4) {\n                        trunc.length = msg.data.length - 4;\n                        for (uint i = 0; i < trunc.length; i++) {\n                                trunc[trunc.length - 1 - i] = msg.data[msg.data.length - 1 - i];\n                        }\n                }\n                hash_to_data[sha3(trunc)] = trunc;\n                lastDataHash = sha3(trunc);\n                lastDataLength = trunc.length;\n                lastData = trunc;\n\n                // Log it.\n                //DataRegistered(lastDataHash);\n        }\n\n        /*\n         *  Call execution API\n         */\n        CallerPool callerPool;\n\n        function getCallerPoolAddress() public returns (address) {\n                return address(callerPool);\n        }\n\n        // This number represents the constant gas cost of the addition\n        // operations that occur in `doCall` that cannot be tracked with\n        // msg.gas.\n        //\n        // NOTE: Currently this value seems to vary between 151761 and 151697.\n        // Until I can understand why this is happening, or account for it, we\n        // use the higher value.\n        uint constant EXTRA_CALL_GAS = 151761;\n        // uint constant EXTRA_CALL_GAS = 151697;\n\n        // This number represents the overall overhead involved in executing a\n        // scheduled call.\n        uint constant CALL_OVERHEAD = 145601;\n\n        //event CallExecuted(address indexed executedBy, bytes32 indexed callKey);\n        //event CallAborted(address indexed executedBy, bytes32 indexed callKey, bytes18 reason);\n\n        function doCall(bytes32 callKey) public {\n                uint gasBefore = msg.gas;\n\n                var call = key_to_calls[callKey];\n\n                if (call.wasCalled) {\n                        // The call has already been executed so don't do it again.\n                        //CallAborted(msg.sender, callKey, \"ALREADY CALLED\");\n                        return;\n                }\n\n                if (call.isCancelled) {\n                        // The call was cancelled so don't execute it.\n                        //CallAborted(msg.sender, callKey, \"CANCELLED\");\n                        return;\n                }\n\n                if (call.contractAddress == 0x0) {\n                        // This call key doesnt map to a registered call.\n                        //CallAborted(msg.sender, callKey, \"UNKNOWN\");\n                        return;\n                }\n\n                if (block.number < call.targetBlock) {\n                        // Target block hasnt happened yet.\n                        //CallAborted(msg.sender, callKey, \"TOO EARLY\");\n                        return;\n                }\n\n                if (block.number > call.targetBlock + call.gracePeriod) {\n                        // The blockchain has advanced passed the period where\n                        // it was allowed to be called.\n                        //CallAborted(msg.sender, callKey, \"TOO LATE\");\n                        return;\n                }\n\n                uint heldBalance = getCallMaxCost(callKey);\n\n                if (accountBalances[call.scheduledBy] < heldBalance) {\n                        // The scheduledBy's account balance is less than the\n                        // current gasLimit and thus potentiall can't pay for\n                        // the call.\n\n                        // Mark it as called since it was.\n                        call.wasCalled = true;\n                        \n                        // Log it.\n                        //CallAborted(msg.sender, callKey, \"INSUFFICIENT_FUNDS\");\n                        return;\n                }\n\n                // Check if this caller is allowed to execute the call.\n                if (callerPool.getPoolSize(callerPool.getActivePoolKey()) > 0) {\n                        address poolCaller = callerPool.getDesignatedCaller(callKey, call.targetBlock, call.gracePeriod, block.number);\n                        if (poolCaller != 0x0 && poolCaller != msg.sender) {\n                                // This call was reserved for someone from the\n                                // bonded pool of callers and can only be\n                                // called by them during this block window.\n                                //CallAborted(msg.sender, callKey, \"WRONG_CALLER\");\n                                return;\n                        }\n\n                        uint blockWindow = (block.number - call.targetBlock) / 4;\n                        if (blockWindow > 0) {\n                                // Someone missed their call so this caller\n                                // gets to claim their bond for picking up\n                                // their slack.\n                                callerPool.awardMissedBlockBonus(msg.sender, callKey, call.targetBlock, call.gracePeriod);\n                        }\n                }\n\n                // Log metadata about the call.\n                call.gasPrice = tx.gasprice;\n                call.executedBy = msg.sender;\n                call.calledAtBlock = block.number;\n\n                // Fetch the call data\n                var data = getCallData(callKey);\n\n                // During the call, we need to put enough funds to pay for the\n                // call on hold to ensure they are available to pay the caller.\n                _deductFunds(call.scheduledBy, heldBalance);\n\n                // Mark whether the function call was successful.\n                if (checkAuthorization(call.scheduledBy, call.contractAddress)) {\n                        call.wasSuccessful = authorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\n                }\n                else {\n                        call.wasSuccessful = unauthorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\n                }\n\n                // Add the held funds back into the scheduler's account.\n                _addFunds(call.scheduledBy, heldBalance);\n\n                // Mark the call as having been executed.\n                call.wasCalled = true;\n\n                // Log the call execution.\n                //CallExecuted(msg.sender, callKey);\n\n                // Compute the scalar (0 - 200) for the fee.\n                uint feeScalar = getCallFeeScalar(call.baseGasPrice, call.gasPrice);\n\n                // Log how much gas this call used.  EXTRA_CALL_GAS is a fixed\n                // amount that represents the gas usage of the commands that\n                // happen after this line.\n                call.gasUsed = (gasBefore - msg.gas + EXTRA_CALL_GAS);\n                call.gasCost = call.gasUsed * call.gasPrice;\n\n                // Now we need to pay the caller as well as keep fee.\n                // callerPayout -> call cost + 1%\n                // fee -> 1% of callerPayout\n                call.payout = call.gasCost * feeScalar * 101 / 10000;\n                call.fee = call.gasCost * feeScalar / 10000;\n\n                _deductFunds(call.scheduledBy, call.payout + call.fee);\n\n                _addFunds(msg.sender, call.payout);\n                _addFunds(owner, call.fee);\n        }\n\n        function getCallMaxCost(bytes32 callKey) public returns (uint) {\n                /*\n                 *  tx.gasprice * block.gaslimit\n                 *  \n                 */\n                // call cost + 2%\n                var call = key_to_calls[callKey];\n\n                uint gasCost = tx.gasprice * block.gaslimit;\n                uint feeScalar = getCallFeeScalar(call.baseGasPrice, tx.gasprice);\n\n                return gasCost * feeScalar * 102 / 10000;\n        }\n\n        function getCallFeeScalar(uint baseGasPrice, uint gasPrice) public returns (uint) {\n                /*\n                 *  Return a number between 0 - 200 to scale the fee based on\n                 *  the gas price set for the calling transaction as compared\n                 *  to the gas price of the scheduling transaction.\n                 *\n                 *  - number approaches zero as the transaction gas price goes\n                 *  above the gas price recorded when the call was scheduled.\n                 *\n                 *  - the number approaches 200 as the transaction gas price\n                 *  drops under the price recorded when the call was scheduled.\n                 *\n                 *  This encourages lower gas costs as the lower the gas price\n                 *  for the executing transaction, the higher the payout to the\n                 *  caller.\n                 */\n                if (gasPrice > baseGasPrice) {\n                        return 100 * baseGasPrice / gasPrice;\n                }\n                else {\n                        return 200 - 100 * baseGasPrice / (2 * baseGasPrice - gasPrice);\n                }\n        }\n\n        /*\n         *  Call Scheduling API\n         */\n\n        // The result of `sha()` so that we can validate that people aren't\n        // looking up call data that failed to register.\n        bytes32 constant emptyDataHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        function getCallKey(address scheduledBy, address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) public returns (bytes32) {\n                return sha3(scheduledBy, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n        }\n\n        // Ten minutes into the future.\n        uint constant MAX_BLOCKS_IN_FUTURE = 40;\n\n        //event CallScheduled(bytes32 indexed callKey);\n        //event CallRejected(bytes32 indexed callKey, bytes15 reason);\n\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) public {\n                /*\n                 * Primary API for scheduling a call.  Prior to calling this\n                 * the data should already have been registered through the\n                 * `registerData` API.\n                 */\n                bytes32 callKey = getCallKey(msg.sender, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n\n                if (dataHash != emptyDataHash && hash_to_data[dataHash].length == 0) {\n                        // Don't allow registering calls if the data hash has\n                        // not actually been registered.  The only exception is\n                        // the *emptyDataHash*.\n                        //CallRejected(callKey, \"NO_DATA\");\n                        return;\n                }\n\n                if (targetBlock < block.number + MAX_BLOCKS_IN_FUTURE) {\n                        // Don't allow scheduling further than\n                        // MAX_BLOCKS_IN_FUTURE\n                        //CallRejected(callKey, \"TOO_SOON\");\n                        return;\n                }\n                var call = key_to_calls[callKey];\n\n                if (call.contractAddress != 0x0) {\n                        //CallRejected(callKey, \"DUPLICATE\");\n                        return;\n                }\n\n                if (gracePeriod < 16) {\n                        //CallRejected(callKey, \"GRACE_TOO_SHORT\");\n                        return;\n                }\n\n                lastCallKey = callKey;\n\n                call.contractAddress = contractAddress;\n                call.scheduledBy = msg.sender;\n                call.nonce = nonce;\n                call.abiSignature = abiSignature;\n                call.dataHash = dataHash;\n                call.targetBlock = targetBlock;\n                call.gracePeriod = gracePeriod;\n                call.baseGasPrice = tx.gasprice;\n\n                placeCallInTree(lastCallKey);\n                rotateTree();\n\n                //CallScheduled(lastCallKey);\n        }\n\n        //event CallCancelled(bytes32 indexed callKey);\n\n        // Two minutes\n        uint constant MIN_CANCEL_WINDOW = 8;\n\n        function cancelCall(bytes32 callKey) public {\n                var call = key_to_calls[callKey];\n                if (call.scheduledBy != msg.sender) {\n                        // Nobody but the scheduler can cancel a call.\n                        return;\n                }\n                if (call.wasCalled) {\n                        // No need to cancel a call that already was executed.\n                        return;\n                }\n                if (call.targetBlock - MIN_CANCEL_WINDOW <= block.number) {\n                        // Call cannot be cancelled this close to execution.\n                        return;\n                }\n                call.isCancelled = true;\n                //CallCancelled(callKey);\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n",
            "userDoc": {
                "methods": {}
            }
        }
    },
    "CallerPool": {
        "code": "0x606060405260008054600160a060020a0319908116331780835560018054909216600160a060020a03909116179055610d5290819061003e90396000f300606060405236156100e55760e060020a600035046319f74e1f811461012957806323306ed614610147578063299179541461015257806350a3bd391461015e5780635ae348681461016a5780636595f73a14610175578063741b3c391461019057806384c92c9a146101985780638dd5e298146101ad578063910789c4146101bf5780639d12f0f5146101fc578063a6814e8e1461023e578063aec918c71461024d578063b010d94a1461026d578063bc966ddc14610282578063c3daab961461028d578063c4afc3fb1461029c578063c861cd66146102b7578063e8543d0d146102cf575b6103135b61031533345b600160a060020a0382166000908152600260205260409020548082011015610346576103465b600080600181548110156100025750508052565b6103176004356024355b600060006000836000141561075957610751565b6103175b3a45025b90565b6103136108ca33610274565b61031361088e336101b4565b61031761020061014f565b6103176004356000818152600460205260409020545b919050565b6103136100e9565b6103176004355b600061072e33610740610242565b6103176004355b60006107c98261019f565b61031760043560038054829081101561000257506000527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b015481565b61031360043560243560443560643560008054819081908190819081908190600160a060020a039081163391909116146104cc575b5050505050505050505050565b6103175b60006106d243610254565b6103176004355b6000600060006003600050546000141561066a57610663565b6103176004355b600061083d82610740610242565b61031761010061014f565b6103136004356103683361019f565b6103175b60006000600360005054600014156106e2576106de565b61031760043560026020526000908152604090205481565b610329600435602435604435606435600060006000600060006000888710806102fc57508760ff16890187115b1561044357600095505b5050505050949350505050565b005b565b60408051918252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b600160a060020a03821660009081526002602052604090208054820190555050565b156103c357600160a060020a03331660009081526002602052604090205481111561039557610395610115565b61039d61014b565b600160a060020a03331660009081526002602052604090205482900310156103c3575b50565b6103f133825b600160a060020a0382166000908152600260205260409020548111156108f3576108f3610115565b604051600160a060020a03331690600090839082818181858883f1935050505015156103c05733600160a060020a03165a60405183906000818181858888f1935050505015156103c0576103c0610115565b61044c89610254565b945084600014156104605760009550610306565b6000858152600460208190526040909120945060ff89811682900416935089880304915060028201839011156104995760009550610306565b508254808a069084908284018190069081101561000257600091825260209091200154600160a060020a03169550610306565b6104d589610254565b600081815260046020819052604090912091985090965060ff898116829004169250438a9003049050600281018290111561054d57600094505b8554851015610231578a600160a060020a03168686815481101561000257600091825260209091200154600160a060020a0316141561056b5761055f565b6002865410156105a157610231565b93505b6001949094019361050f565b8585815481101561000257600091825260209091200154600160a060020a0316925061055c838c5b60006000600061091661014b565b600094505b8554851015610231578a600160a060020a03168686815481101561000257600091825260209091200154600160a060020a0316141561061157858654600188548801030681548110156100025760206000200154600160a060020a0316935061061d9050838c610593565b600194909401936105a6565b93506106276102a0565b6000141561063d5761063d5b600061095c6102a0565b610231836106496102a0565b600060008260001415610b6857610b68610115565b600092505b5050919050565b600091505b60035482101561065e57600380548381036000190190811015610002576000919091527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b015490508381116106c657809250610663565b6001919091019061066f565b905061014f565b600091505b5090565b60038054600019810190811015610002576000919091527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b01549050438111156106d9578091506106de565b806107455750610745336107406102a0565b610133565b905061018b565b600092505b505092915050565b60008481526004602052604081208054909350141561077b5760009250610751565b5060005b815481101561074c5784600160a060020a03168282815481101561000257600091825260209091200154600160a060020a031614156107c15760019250610751565b60010161077f565b156107d65750600061018b565b6107de6102a0565b6000141580156107f957506101006107f46102a0565b034310155b156108065750600061018b565b61080e61014b565b600160a060020a03831660009081526002602052604090205410156108355750600061018b565b50600161018b565b151561084b5750600061018b565b6108536102a0565b600014610835576101006108656102a0565b0343106108745750600061018b565b610880826107406102a0565b15156108355750600061018b565b156103155761089b6102a0565b600014156108ab576108ab610633565b610315336108b76102a0565b60008160001415610b1557610b15610115565b15610315576108d76102a0565b600014156108e7576108e7610633565b610315336106496102a0565b600160a060020a0382166000908152600260205260409020805482900390555050565b600160a060020a038616600090815260026020526040902054909250905080821115610940579050805b61094a85836103c9565b61095484836100ef565b819250610751565b60001461096b5761096b610115565b5061020043016004600061097d610242565b815260208181019290925260409081016000908120848252600484529181208254815481835582845294909220909381019282156109dc5760005260206000209182015b828111156109dc5782548255916001019190600101906109c1565b50610a029291505b808211156106de578054600160a060020a03191681556001016109e4565b5050610a4f8160008181526004602052604081209080805b8354811015610c9a578354604080514340815260208101849052815190819003909101902006925082811415610ca157610d4a565b6003805460018101808355919082908015829011610a9057818360005260206000209182019101610a9091905b808211156106de5760008155600101610a7c565b505060038054849350909150600019810190811015610002575080546000919091527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85a015550565b50505050828160018354038154811015610002575050815460008381526020902001600019018054600160a060020a03191690911790555b505050565b610b1f8383610133565b15610b2957610b10565b50600081815260046020526040902080546001810180835590829082908015829011610ad857818360005260206000209182019101610ad89190610a7c565b610b728484610133565b1515610b7d57610c8c565b6000838152600460205260409020805490925060011415610bc75760008281815481835581811511610bc257818360005260206000209182019101610bc29190610a7c565b505050505b5060005b8154811015610c8c5783600160a060020a03168282815481101561000257600091825260209091200154600160a060020a03161415610c9257816001835403815481101561000257906000526020600020900160009054906101000a9004600160a060020a031682828154811015610002576020600020018054600160a060020a031916909217909155508154600019810180845590839082908015829011610c8757818360005260206000209182019101610c879190610a7c565b505050505b50505050565b600101610bcb565b5050505050565b8381815481101561000257508054600082815260209020830154600160a060020a03169350849081101561000257906000526020600020900160009054906101000a9004600160a060020a0316848281548110156100025750602060002083018054600160a060020a03191690921790915550835482908590859081101561000257906000526020600020900160006101000a815481600160a060020a03021916908302179055505b600101610a1a56",
        "info": {
            "abiDefinition": [
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callerAddress",
                            "type": "address"
                        },
                        {
                            "name": "poolNumber",
                            "type": "uint256"
                        }
                    ],
                    "name": "isInPool",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "getMinimumBond",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "exitPool",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "enterPool",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "getPoolMinimumLength",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "poolKey",
                            "type": "uint256"
                        }
                    ],
                    "name": "getPoolSize",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "depositBond",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callerAddress",
                            "type": "address"
                        }
                    ],
                    "name": "isInAnyPool",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callerAddress",
                            "type": "address"
                        }
                    ],
                    "name": "canEnterPool",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "name": "poolHistory",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "toCaller",
                            "type": "address"
                        },
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        },
                        {
                            "name": "targetBlock",
                            "type": "uint256"
                        },
                        {
                            "name": "gracePeriod",
                            "type": "uint8"
                        }
                    ],
                    "name": "awardMissedBlockBonus",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "getActivePoolKey",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "blockNumber",
                            "type": "uint256"
                        }
                    ],
                    "name": "getPoolKeyForBlock",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callerAddress",
                            "type": "address"
                        }
                    ],
                    "name": "canExitPool",
                    "outputs": [
                        {
                            "name": "",
                            "type": "bool"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "getPoolFreezeDuration",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "value",
                            "type": "uint256"
                        }
                    ],
                    "name": "withdrawBond",
                    "outputs": [],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [],
                    "name": "getNextPoolKey",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": true,
                    "inputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "name": "callerBonds",
                    "outputs": [
                        {
                            "name": "",
                            "type": "uint256"
                        }
                    ],
                    "type": "function"
                },
                {
                    "constant": false,
                    "inputs": [
                        {
                            "name": "callKey",
                            "type": "bytes32"
                        },
                        {
                            "name": "targetBlock",
                            "type": "uint256"
                        },
                        {
                            "name": "gracePeriod",
                            "type": "uint8"
                        },
                        {
                            "name": "blockNumber",
                            "type": "uint256"
                        }
                    ],
                    "name": "getDesignatedCaller",
                    "outputs": [
                        {
                            "name": "",
                            "type": "address"
                        }
                    ],
                    "type": "function"
                },
                {
                    "inputs": [],
                    "type": "constructor"
                }
            ],
            "compilerVersion": "0.1.1-ed7a8a35",
            "developerDoc": {
                "methods": {}
            },
            "language": "Solidity",
            "languageVersion": "0",
            "source": "contract Relay {\n        address operator;\n\n        function Relay() {\n                operator = msg.sender;\n        }\n\n        function relayCall(address contractAddress, bytes4 abiSignature, bytes data) public returns (bool) {\n                if (msg.sender != operator) {\n                        __throw();\n                }\n                return contractAddress.call(abiSignature, data);\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n\n\ncontract CallerPoolAlarmAPI {\n        /*\n         *  Abstract contract for the caller pool to be able to access the\n         *  Alarm api.\n         */\n        function getCallGracePeriod(bytes32 callKey) public returns (uint);\n        function getCallTargetBlock(bytes32 callKey) public returns (uint);\n}\n\n\ncontract CallerPool {\n        address operator;\n        CallerPoolAlarmAPI alarm;\n\n        function CallerPool() {\n                operator = msg.sender;\n                alarm = CallerPoolAlarmAPI(operator);\n        }\n\n        /*\n         *  Caller bonding\n         */\n        mapping (address => uint) public callerBonds;\n\n        function getMinimumBond() public returns (uint) {\n                return tx.gasprice * block.gaslimit;\n        }\n\n        function _deductFromBond(address callerAddress, uint value) internal {\n                /*\n                 *  deduct funds from a bond value without risk of an\n                 *  underflow.\n                 */\n                if (value > callerBonds[callerAddress]) {\n                        // Prevent Underflow.\n                        __throw();\n                }\n                callerBonds[callerAddress] -= value;\n        }\n\n        function _addToBond(address callerAddress, uint value) internal {\n                /*\n                 *  Add funds to a bond value without risk of an\n                 *  overflow.\n                 */\n                if (callerBonds[callerAddress] + value < callerBonds[callerAddress]) {\n                        // Prevent Overflow\n                        __throw();\n                }\n                callerBonds[callerAddress] += value;\n        }\n\n        function depositBond() public {\n                _addToBond(msg.sender, msg.value);\n        }\n\n        function withdrawBond(uint value) public {\n                /*\n                 *  Only if you are not in either of the current call pools.\n                 */\n                if (isInAnyPool(msg.sender)) {\n                        // Prevent underflow\n                        if (value > callerBonds[msg.sender]) {\n                                __throw();\n                        }\n                        // Don't allow withdrawl if this would drop the bond\n                        // balance below the minimum.\n                        if (callerBonds[msg.sender] - value < getMinimumBond()) {\n                                return;\n                        }\n                }\n                _deductFromBond(msg.sender, value);\n                if (!msg.sender.send(value)) {\n                        // Potentially sending money to a contract that\n                        // has a fallback function.  So instead, try\n                        // tranferring the funds with the call api.\n                        if (!msg.sender.call.gas(msg.gas).value(value)()) {\n                                // Revert the entire transaction.  No\n                                // need to destroy the funds.\n                                __throw();\n                        }\n                }\n        }\n\n        function() {\n                /*\n                 *  Fallback function that allows depositing bond funds just by\n                 *  sending a transaction.\n                 */\n                _addToBond(msg.sender, msg.value);\n        }\n\n        /*\n         *  API used by Alarm service\n         */\n        function getDesignatedCaller(bytes32 callKey, uint targetBlock, uint8 gracePeriod, uint blockNumber) public returns (address) {\n                /*\n                 *  Returns the caller from the current call pool who is\n                 *  designated as the executor of this call.\n                 */\n                if (blockNumber < targetBlock || blockNumber > targetBlock + gracePeriod) {\n                        // blockNumber not within call window.\n                        return 0x0;\n                }\n\n                // Pool used is based on the starting block for the call.  This\n                // allows us to know that the pool cannot change for at least\n                // POOL_FREEZE_NUM_BLOCKS which is kept greater than the max\n                // grace period.\n                uint poolNumber = getPoolKeyForBlock(targetBlock);\n                if (poolNumber == 0) {\n                        // No pool currently in operation.\n                        return 0x0;\n                }\n                var pool = callerPools[poolNumber];\n\n                uint numWindows = gracePeriod / 4;\n                uint blockWindow = (blockNumber - targetBlock) / 4;\n\n                if (blockWindow + 2 > numWindows) {\n                        // We are within the free-for-all period.\n                        return 0x0;\n                }\n\n                uint offset = uint(callKey) % pool.length;\n                return pool[(offset + blockWindow) % pool.length];\n        }\n\n        //event AwardedMissedBlockBonus(address indexed fromCaller, address indexed toCaller, uint indexed poolNumber, bytes32 callKey, uint blockNumber, uint bonusAmount);\n\n        function _doBondBonusTransfer(address fromCaller, address toCaller) internal returns (uint) {\n                uint bonusAmount = getMinimumBond();\n                uint bondBalance = callerBonds[fromCaller];\n\n                // If the bond balance is lower than the award\n                // balance, then adjust the reward amount to\n                // match the bond balance.\n                if (bonusAmount > bondBalance) {\n                        bonusAmount = bondBalance;\n                }\n\n                // Transfer the funds fromCaller => toCaller\n                _deductFromBond(fromCaller, bonusAmount);\n                _addToBond(toCaller, bonusAmount);\n\n                return bonusAmount;\n        }\n\n        function awardMissedBlockBonus(address toCaller, bytes32 callKey, uint targetBlock, uint8 gracePeriod) public {\n                if (msg.sender != operator) {\n                        return;\n                }\n\n                uint poolNumber = getPoolKeyForBlock(targetBlock);\n                var pool = callerPools[poolNumber];\n                uint i;\n                uint bonusAmount;\n                address fromCaller;\n\n                uint numWindows = gracePeriod / 4;\n                uint blockWindow = (block.number - targetBlock) / 4;\n\n                // Check if we are within the free-for-all period.  If so, we\n                // award from all pool members.\n                if (blockWindow + 2 > numWindows) {\n                        for (i = 0; i < pool.length; i++) {\n                                if (pool[i] == toCaller) {\n                                        continue;\n                                }\n                                fromCaller = pool[i];\n                                bonusAmount = _doBondBonusTransfer(fromCaller, toCaller);\n\n                                // Log the bonus was awarded.\n                                //AwardedMissedBlockBonus(fromCaller, toCaller, poolNumber, callKey, block.number, bonusAmount);\n                        }\n                        return;\n                }\n\n                // Special case for single member and empty pools\n                if (pool.length < 2) {\n                        return;\n                }\n\n                // Otherwise the award comes from the previous caller.\n                for (i = 0; i < pool.length; i++) {\n                        // Find where the member is in the pool and\n                        // award from the previous pool members bond.\n                        if (pool[i] == toCaller) {\n                                fromCaller = pool[(i + pool.length - 1) % pool.length];\n\n                                bonusAmount = _doBondBonusTransfer(fromCaller, toCaller);\n\n                                // Log the bonus was awarded.\n                                //AwardedMissedBlockBonus(fromCaller, toCaller, poolNumber, callKey, block.number, bonusAmount);\n\n                                // Remove the caller from the next pool.\n                                if (getNextPoolKey() == 0) {\n                                        // This is the first address to modify the\n                                        // current pool so we need to setup the next\n                                        // pool.\n                                        _initiateNextPool();\n                                }\n                                _removeFromPool(fromCaller, getNextPoolKey());\n                                return;\n                        }\n                }\n        }\n\n        /*\n         *  Caller Pool Management\n         */\n        uint[] public poolHistory;\n        mapping (uint => address[]) callerPools;\n\n        function getPoolKeyForBlock(uint blockNumber) public returns (uint) {\n                if (poolHistory.length == 0) {\n                        return 0;\n                }\n                for (uint i = 0; i < poolHistory.length; i++) {\n                        uint poolStartBlock = poolHistory[poolHistory.length - i - 1];\n                        if (poolStartBlock <= blockNumber) {\n                                return poolStartBlock;\n                        }\n                }\n                return 0;\n        }\n\n        function getActivePoolKey() public returns (uint) {\n                return getPoolKeyForBlock(block.number);\n        }\n\n        function getPoolSize(uint poolKey) returns (uint) {\n                return callerPools[poolKey].length;\n        }\n\n        function getNextPoolKey() public returns (uint) {\n                if (poolHistory.length == 0) {\n                        return 0;\n                }\n                uint latestPool = poolHistory[poolHistory.length - 1];\n                if (latestPool > block.number) {\n                        return latestPool;\n                }\n                return 0;\n        }\n\n        function isInAnyPool(address callerAddress) public returns (bool) {\n                /*\n                 *  Returns boolean whether the `callerAddress` is in either\n                 *  the current active pool or the next pool.\n                 */\n                return isInPool(msg.sender, getActivePoolKey()) || isInPool(msg.sender, getNextPoolKey());\n        }\n\n        function isInPool(address callerAddress, uint poolNumber) public returns (bool) {\n                /*\n                 *  Returns boolean whether the `callerAddress` is in the\n                 *  poolNumber.\n                 */\n                if (poolNumber == 0 ) {\n                        // Nobody can be in pool 0\n                        return false;\n                }\n\n                var pool = callerPools[poolNumber];\n\n                // Nobody is in the pool.\n                if (pool.length == 0) {\n                        return false;\n                }\n\n                for (uint i = 0; i < pool.length; i++) {\n                        // Address is in the pool and thus is allowed to exit.\n                        if (pool[i] == callerAddress) {\n                                return true;\n                        }\n                }\n\n                return false;\n        }\n\n        // Ten minutes into the future.\n        uint constant POOL_FREEZE_NUM_BLOCKS = 256;\n        //uint constant POOL_FREEZE_NUM_BLOCKS = 40;\n\n        function getPoolFreezeDuration() public returns (uint) {\n                return POOL_FREEZE_NUM_BLOCKS;\n        }\n\n        function getPoolMinimumLength() public returns (uint) {\n                return 2 * POOL_FREEZE_NUM_BLOCKS;\n        }\n\n        function canEnterPool(address callerAddress) public returns (bool) {\n                /*\n                 *  Returns boolean whether `callerAddress` is allowed to enter\n                 *  the next pool (which may or may not already have been\n                 *  created.\n                 */\n                // Not allowed to join if you are in either the current\n                // active pool or the next pool.\n                if (isInAnyPool(callerAddress)) {\n                        return false;\n                }\n\n                // Next pool begins within the POOL_FREEZE_NUM_BLOCKS grace\n                // period so no changes are allowed.\n                if (getNextPoolKey() != 0 && block.number >= (getNextPoolKey() - POOL_FREEZE_NUM_BLOCKS)) {\n                        return false;\n                }\n\n                // Account bond balance is too low.\n                if (callerBonds[callerAddress] < getMinimumBond()) {\n                        return false;\n                }\n                \n                return true;\n        }\n\n        function canExitPool(address callerAddress) public returns (bool) {\n                /*\n                 *  Returns boolean whether `callerAddress` is allowed to exit\n                 *  the current active pool.\n                 */\n                // Can't exit if we aren't in the current active pool.\n                if (!isInPool(callerAddress, getActivePoolKey())) {\n                        return false;\n                }\n\n                // There is a next pool coming up.\n                if (getNextPoolKey() != 0) {\n                        // Next pool begins within the POOL_FREEZE_NUM_BLOCKS\n                        // window and thus can't be modified.\n                        if (block.number >= (getNextPoolKey() - POOL_FREEZE_NUM_BLOCKS)) {\n                                return false;\n                        }\n\n                        // Next pool was already setup and callerAddress isn't\n                        // in it which indicates that they already left.\n                        if (!isInPool(callerAddress, getNextPoolKey())) {\n                                return false;\n                        }\n                }\n\n                // They must be in the current pool and either the next pool\n                // hasn't been initiated or it has but this user hasn't left\n                // yet.\n                return true;\n        }\n\n        function _initiateNextPool() internal {\n                if (getNextPoolKey() != 0) {\n                        // If there is already a next pool, we shouldn't\n                        // initiate a new one until it has become active.\n                        __throw();\n                }\n                // Set the next pool to start at double the freeze block number\n                // in the future.\n                uint nextPool = block.number + 2 * POOL_FREEZE_NUM_BLOCKS;\n\n                // Copy the current pool into the next pool.\n                callerPools[nextPool] = callerPools[getActivePoolKey()];\n\n                // Randomize the pool order\n                _shufflePool(nextPool);\n\n                // Push the next pool into the pool history.\n                poolHistory.length += 1;\n                poolHistory[poolHistory.length - 1] = nextPool;\n        }\n\n        function _shufflePool(uint poolNumber) internal {\n                var pool = callerPools[poolNumber];\n\n                uint swapIndex;\n                address buffer;\n\n                for (uint i = 0; i < pool.length; i++) {\n                        swapIndex = uint(sha3(block.blockhash(block.number), i)) % pool.length;\n                        if (swapIndex == i) {\n                                continue;\n                        }\n                        buffer = pool[i];\n                        pool[i] = pool[swapIndex];\n                        pool[swapIndex] = buffer;\n                }\n        }\n\n        //event AddedToPool(address indexed callerAddress, uint indexed pool);\n        //event RemovedFromPool(address indexed callerAddress, uint indexed pool);\n\n        function _addToPool(address callerAddress, uint poolNumber) internal {\n                if (poolNumber == 0 ) {\n                        // This shouldn't be called with 0;\n                        __throw();\n                }\n\n                // already in the pool.\n                if (isInPool(callerAddress, poolNumber)) {\n                        return;\n                }\n                var pool = callerPools[poolNumber];\n                pool.length += 1;\n                pool[pool.length - 1] = callerAddress;\n                \n                // Log the addition.\n                //AddedToPool(callerAddress, poolNumber);\n        }\n\n        function _removeFromPool(address callerAddress, uint poolNumber) internal {\n                if (poolNumber == 0 ) {\n                        // This shouldn't be called with 0;\n                        __throw();\n                }\n\n                // nothing to remove.\n                if (!isInPool(callerAddress, poolNumber)) {\n                        return;\n                }\n                var pool = callerPools[poolNumber];\n                // special case length == 1\n                if (pool.length == 1) {\n                        pool.length = 0;\n                }\n                for (uint i = 0; i < pool.length; i++) {\n                        // When we find the index of the address to remove we\n                        // shift the last person to that location and then we\n                        // truncate the last member off of the end.\n                        if (pool[i] == callerAddress) {\n                                pool[i] = pool[pool.length - 1];\n                                pool.length -= 1;\n                                break;\n                        }\n                }\n\n                // Log the addition.\n                //RemovedFromPool(callerAddress, poolNumber);\n        }\n\n        function enterPool() public {\n                /*\n                 *  Request to be added to the call pool.\n                 */\n                if (canEnterPool(msg.sender)) {\n                        if (getNextPoolKey() == 0) {\n                                // This is the first address to modify the\n                                // current pool so we need to setup the next\n                                // pool.\n                                _initiateNextPool();\n                        }\n                        _addToPool(msg.sender, getNextPoolKey());\n                }\n        }\n\n        function exitPool() public {\n                /*\n                 *  Request to be removed from the call pool.\n                 */\n                if (canExitPool(msg.sender)) {\n                        if (getNextPoolKey() == 0) {\n                                // This is the first address to modify the\n                                // current pool so we need to setup the next\n                                // pool.\n                                _initiateNextPool();\n                        }\n                        _removeFromPool(msg.sender, getNextPoolKey());\n                }\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n\n\ncontract Alarm {\n        /*\n         *  Administration API\n         *\n         *  There is currently no special administrative API beyond the hard\n         *  coded owner address which receives 1% of each executed call.  This\n         *  eliminates any need for trust as nobody has any special access.\n         */\n        function Alarm() {\n                unauthorizedRelay = new Relay();\n                authorizedRelay = new Relay();\n                callerPool = new CallerPool();\n        }\n\n        address constant owner = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\n\n        /*\n         *  Account Management API\n         */\n        mapping (address => uint) public accountBalances;\n\n        function _deductFunds(address accountAddress, uint value) internal {\n                /*\n                 *  Helper function that should be used for any reduction of\n                 *  account funds.  It has error checking to prevent\n                 *  underflowing the account balance which would be REALLY bad.\n                 */\n                if (value > accountBalances[accountAddress]) {\n                        // Prevent Underflow.\n                        __throw();\n                }\n                accountBalances[accountAddress] -= value;\n        }\n\n        function _addFunds(address accountAddress, uint value) internal {\n                /*\n                 *  Helper function that should be used for any addition of\n                 *  account funds.  It has error checking to prevent\n                 *  overflowing the account balance.\n                 */\n                if (accountBalances[accountAddress] + value < accountBalances[accountAddress]) {\n                        // Prevent Overflow.\n                        __throw();\n                }\n                accountBalances[accountAddress] += value;\n        }\n\n        //event Deposit(address indexed _from, address indexed accountAddress, uint value);\n\n        function deposit(address accountAddress) public {\n                /*\n                 *  Public API for depositing funds in a specified account.\n                 */\n                _addFunds(accountAddress, msg.value);\n                //Deposit(msg.sender, accountAddress, msg.value);\n        }\n\n        //event Withdraw(address indexed accountAddress, uint value);\n\n        function withdraw(uint value) public {\n                /*\n                 *  Public API for withdrawing funds.\n                 */\n                if (accountBalances[msg.sender] >= value) {\n                        _deductFunds(msg.sender, value);\n                        if (!msg.sender.send(value)) {\n                                // Potentially sending money to a contract that\n                                // has a fallback function.  So instead, try\n                                // tranferring the funds with the call api.\n                                if (!msg.sender.call.gas(msg.gas).value(value)()) {\n                                        // Revert the entire transaction.  No\n                                        // need to destroy the funds.\n                                        __throw();\n                                }\n                        }\n                        //Withdraw(msg.sender, value);\n                }\n        }\n\n        function() {\n                /*\n                 *  Fallback function that allows depositing funds just by\n                 *  sending a transaction.\n                 */\n                _addFunds(msg.sender, msg.value);\n                //Deposit(msg.sender, msg.sender, msg.value);\n        }\n\n        /*\n         *  Call tracking API\n         */\n        struct Node {\n                bytes32 callKey;\n                bytes32 left;\n                bytes32 right;\n        }\n\n        bytes32 public rootNodeCallKey;\n\n        mapping (bytes32 => Node) call_to_node;\n\n        function _getTreeMaxBlock(bytes32 callKey) internal returns (uint) {\n                /*\n                 *  Returns the greatest block number for all calls in the\n                 *  section of the call tree denoted by callKey.\n                 */\n                Node currentNode = call_to_node[callKey];\n\n                while (true) {\n                        if (currentNode.right == 0x0) {\n                                return key_to_calls[currentNode.callKey].targetBlock;\n                        }\n\n                        currentNode = call_to_node[currentNode.right];\n                }\n        }\n\n        function _shouldGoLeft(bytes32 callKey, uint blockNumber) internal returns (bool) {\n                /*\n                 * not if left is empty\n                 * not if current node was already called\n                 * not if current node is in the past or current block.\n                 * not if left node is in the past.\n                 */\n                Node currentNode = call_to_node[callKey];\n\n                // Nowhere to go.\n                if (currentNode.left == 0x0) {\n                        return false;\n                }\n\n                Call currentCall = key_to_calls[callKey];\n\n                // Current call is already in the past or is up next.\n                if (currentCall.targetBlock <= blockNumber) {\n                        return false;\n                }\n\n                // Left call is in the past\n                if (blockNumber > _getTreeMaxBlock(currentNode.left)) {\n                        return false;\n                }\n\n                return true;\n        }\n\n        function _shouldGoRight(bytes32 callKey, uint blockNumber) internal returns (bool) {\n                /*\n                 * not if right is empty.\n                 * not if current node is already in the future.\n                 * not if current node is equal to targetBlock and it isn't already called.\n                 *\n                 */\n                Node currentNode = call_to_node[callKey];\n\n                // Nowhere to go.\n                if (currentNode.right == 0x0) {\n                        return false;\n                }\n\n                Call currentCall = key_to_calls[callKey];\n\n                // Current call is already in the future\n                if (currentCall.targetBlock > blockNumber) {\n                        return false;\n                }\n\n                // Current call equals the desired block number and has not\n                // been called yet and is not cancelled.\n                if (currentCall.targetBlock == blockNumber) {\n                        return false;\n                }\n\n                return true;\n        }\n\n        function getNextBlockWithCall(uint blockNumber) public returns (uint) {\n                bytes32 nextCallKey = getNextCallKey(blockNumber);\n                if (nextCallKey == 0x0) {\n                        return 0;\n                }\n                return key_to_calls[nextCallKey].targetBlock;\n        }\n\n        function getNextCallKey(uint blockNumber) public returns (bytes32) {\n                if (rootNodeCallKey == 0x0) {\n                        // No calls registered\n                        return 0x0;\n                }\n\n                Node currentNode = call_to_node[rootNodeCallKey];\n\n                while (true) {\n                        if (_shouldGoLeft(currentNode.callKey, blockNumber)) {\n                                currentNode = call_to_node[currentNode.left];\n                                continue;\n                        }\n                        if (_shouldGoRight(currentNode.callKey, blockNumber)) {\n                                currentNode = call_to_node[currentNode.right];\n                                continue;\n                        }\n\n                        // Not if it is before the blockNumber\n                        if (key_to_calls[currentNode.callKey].targetBlock < blockNumber) {\n                                return 0x0;\n                        }\n\n                        // Then it must be the next one.\n                        return currentNode.callKey;\n                }\n        }\n\n        function _isBlockNumberInTree(bytes32 callKey, uint blockNumber) internal returns (bool) {\n                var node = call_to_node[callKey];\n\n                while (true) {\n                        var call = key_to_calls[node.callKey];\n\n                        if (call.targetBlock == blockNumber) {\n                                return true;\n                        }\n\n                        if (node.left != 0x0 && call.targetBlock > blockNumber) {\n                                node = call_to_node[node.left];\n                                continue;\n                        }\n\n                        if (node.right != 0x0 && call.targetBlock < blockNumber) {\n                                node = call_to_node[node.right];\n                                continue;\n                        }\n\n                        return false;\n                }\n        }\n\n        function getNextCallSibling(bytes32 callKey) public returns (bytes32) {\n                /*\n                 *  Returns the callKey any subsequent calls that have the same\n                 *  block number as the provided callKey.  If there are no\n                 *  subsequent calls with the same block number returns 0x0\n                 */\n                var node = call_to_node[callKey];\n                var call = key_to_calls[callKey];\n                uint targetBlock = call.targetBlock;\n\n                while (true) {\n                        if (node.right != 0x0 && _isBlockNumberInTree(node.right, targetBlock)) {\n                                node = call_to_node[node.right];\n                                call = key_to_calls[node.callKey];\n                                if (call.targetBlock == targetBlock) {\n                                        return node.callKey;\n                                }\n                                continue;\n                        }\n\n                        if (node.left != 0x0 && _isBlockNumberInTree(node.left, targetBlock)) {\n                                node = call_to_node[node.left];\n                                call = key_to_calls[node.callKey];\n                                if (call.targetBlock == targetBlock) {\n                                        return node.callKey;\n                                }\n                                continue;\n                        }\n\n                        return 0x0;\n                }\n        }\n\n        function getCallLeftChild(bytes32 callKey) public returns (bytes32) {\n                return call_to_node[callKey].left;\n        }\n\n        function getCallRightChild(bytes32 callKey) public returns (bytes32) {\n                return call_to_node[callKey].right;\n        }\n\n        //event CallPlacedInTree(bytes32 indexed callKey);\n\n        function placeCallInTree(bytes32 callKey) internal {\n                /*\n                 * Calls are stored in a tree structure.  Each tree node\n                 * represents a single call.  Nodes have a left and right\n                 * child.  The left child represents a call that should happen\n                 * before the node.  The right child represents a call that\n                 * should happen after the node.\n                 */\n                Call targetCall = key_to_calls[callKey];\n\n                if (callKey == call_to_node[callKey].callKey) {\n                        // This call key is already placed in the tree.\n                        return;\n                }\n\n                if (rootNodeCallKey == 0x0) {\n                        // This is the first call placement and thus should be\n                        // set as the root node.\n                        rootNodeCallKey = callKey;\n                }\n\n                Node currentNode = call_to_node[rootNodeCallKey];\n\n                while (true) {\n                        if (currentNode.callKey == 0x0) {\n                                // This is a new node and should be mapped \n                                currentNode.callKey = callKey;\n                                //CallPlacedInTree(callKey);\n                                return;\n                        }\n\n                        Call currentCall = key_to_calls[currentNode.callKey];\n\n                        if (targetCall.targetBlock < currentCall.targetBlock) {\n                                // Call should occure before the current node\n                                // and thus should exist in the left subtree.\n                                if (currentNode.left == 0x0) {\n                                        currentNode.left = callKey;\n                                }\n                                currentNode = call_to_node[currentNode.left];\n                                continue;\n                        }\n\n                        // Call should occur after the current node and thus\n                        // should exist in the right subtree.\n                        if (currentNode.right == 0x0) {\n                                currentNode.right = callKey;\n                        }\n                        currentNode = call_to_node[currentNode.right];\n                }\n        }\n\n        //event TreeRotatedRight(bytes32 indexed oldRootNodeCallKey, bytes32 indexed newRootNodeCallKey);\n\n        //function _rotateRight() internal {\n        //        /*\n        //         *  1. Detatch the left child of the root node.  This is the\n        //         *     new root node.\n        //         *  2. Detatch the right child of the new root node.\n        //         *  3. Set the old root node as the right child of the new root node.\n        //         *  4. Set the detatched right child from the new root node in\n        //         *     the appropriate location in the tree.\n        //         */\n        //        var oldRootNode = call_to_node[rootNodeCallKey];\n        //        var newRootNode = call_to_node[oldRootNode.left];\n        //        // #1\n        //        oldRootNode.left = 0x0;\n        //        rootNodeCallKey = newRootNode.callKey;\n\n        //        // #2\n        //        bytes32 detatchedChildCallKey = newRootNode.right;\n        //        newRootNode.right = 0x0;\n\n        //        // #3\n        //        newRootNode.right = oldRootNode.callKey;\n\n        //        // #4\n        //        if (detatchedChildCallKey != 0x0) {\n        //                // First reset the node to not have a callKey,\n        //                // otherwise the call to `placeCallInTree` will exit\n        //                // early thinking this node is already placed.\n        //                var detatchedChildNode = call_to_node[detatchedChildCallKey];\n        //                detatchedChildNode.callKey = 0x0;\n        //                // Now place it at it's new location in the tree.\n        //                placeCallInTree(detatchedChildCallKey);\n        //        }\n\n        //        //TreeRotatedRight(oldRootNode.callKey, newRootNode.callKey);\n        //}\n\n        //function _shouldRotateRight() internal returns (bool) {\n        //        /*\n        //         *  Is the left child of the rootNode in the future of the\n        //         *  current block number.\n        //         */\n        //        if (rootNodeCallKey == 0x0) {\n        //                return false;\n        //        }\n\n        //        var currentRoot = call_to_node[rootNodeCallKey];\n\n        //        // No left child so cant rotate right.\n        //        if (currentRoot.left == 0x0) {\n        //                return false;\n        //        }\n\n        //        // Current root already in the past.\n        //        if (key_to_calls[rootNodeCallKey].targetBlock <= block.number) {\n        //                return false;\n        //        }\n\n        //        return true;\n        //}\n\n        //event TreeRotatedLeft(bytes32 indexed oldRootNodeCallKey, bytes32 indexed newRootNodeCallKey);\n\n        function _rotateLeft() internal {\n                /*\n                 *  1. Detatch the right child of the root node.  This is the\n                 *     new root node.\n                 *  2. Detatch the left child of the new root node.\n                 *  3. Set the old root node as the left child of the new root node.\n                 *  4. Set the detatched left child from the new root node in\n                 *     the appropriate location in the tree.\n                 */\n                var oldRootNode = call_to_node[rootNodeCallKey];\n                var newRootNode = call_to_node[oldRootNode.right];\n                // #1\n                oldRootNode.right = 0x0;\n                rootNodeCallKey = newRootNode.callKey;\n\n                // #2\n                bytes32 detatchedChildCallKey = newRootNode.left;\n\n                // #3\n                newRootNode.left = oldRootNode.callKey;\n\n                // #4\n                if (detatchedChildCallKey != 0x0) {\n                        // First reset the node to not have a callKey,\n                        // otherwise the call to `placeCallInTree` will exit\n                        // early thinking this node is already placed.\n                        var detatchedChildNode = call_to_node[detatchedChildCallKey];\n                        detatchedChildNode.callKey = 0x0;\n                        // Now place it at it's new location in the tree.\n                        placeCallInTree(detatchedChildCallKey);\n                }\n                //TreeRotatedLeft(oldRootNode.callKey, newRootNode.callKey);\n        }\n\n        function _shouldRotateLeft() internal returns (bool) {\n                /*\n                 *  We should rotate left if both the current root node, and\n                 *  its right child are both in the past.\n                 */\n                // Empty call tree.\n                if (rootNodeCallKey == 0x0) {\n                        return false;\n                }\n\n                var currentRoot = call_to_node[rootNodeCallKey];\n\n                // No right child so cant rotate left.\n                if (currentRoot.right == 0x0) {\n                        return false;\n                }\n\n                // Current root already in the future.\n                if (key_to_calls[rootNodeCallKey].targetBlock >= block.number) {\n                        return false;\n                }\n\n                if (key_to_calls[currentRoot.right].targetBlock >= block.number) {\n                        return false;\n                }\n\n                return true;\n        }\n\n        function rotateTree() public {\n                /*\n                 *  Shifts the root node of the tree so that the root node is\n                 *  the tree node prior to the next scheduled call.\n                 */\n                if (rootNodeCallKey == 0x0) {\n                        // No root node (empty tree)\n                        return;\n                }\n\n                var currentRoot = call_to_node[rootNodeCallKey];\n                var rootBlockNumber = key_to_calls[rootNodeCallKey].targetBlock;\n\n                // The current root is in the past so we can potentially rotate\n                // the tree to the left to increase the root block number.\n                if (rootBlockNumber < block.number) {\n                        while (_shouldRotateLeft()) {\n                                _rotateLeft();\n                        }\n                        return;\n                }\n\n                // The current root is in the future so we can potentially\n                // rotate the tree to the right to decrease the root block\n                // number.\n                //if (rootBlockNumber > block.number) {\n                //        while (_shouldRotateRight()) {\n                //                _rotateRight();\n                //        }\n                //}\n        }\n\n        /*\n         *  Scheduling Authorization API\n         */\n        Relay unauthorizedRelay;\n        Relay authorizedRelay;\n\n        function unauthorizedAddress() public returns (address) {\n                return address(unauthorizedRelay);\n        }\n\n        function authorizedAddress() public returns (address) {\n                return address(authorizedRelay);\n        }\n\n        mapping (bytes32 => bool) accountAuthorizations;\n\n        function addAuthorization(address schedulerAddress) public {\n                accountAuthorizations[sha3(schedulerAddress, msg.sender)] = true;\n        }\n\n        function removeAuthorization(address schedulerAddress) public {\n                accountAuthorizations[sha3(schedulerAddress, msg.sender)] = false;\n        }\n\n        function checkAuthorization(address schedulerAddress, address contractAddress) public returns (bool) {\n                return accountAuthorizations[sha3(schedulerAddress, contractAddress)];\n        }\n\n        /*\n         *  Call Information API\n         */\n        bytes32 lastCallKey;\n\n        function getLastCallKey() public returns (bytes32) {\n                return lastCallKey;\n        }\n\n        struct Call {\n                address contractAddress;\n                address scheduledBy;\n                uint calledAtBlock;\n                uint targetBlock;\n                uint8 gracePeriod;\n                uint nonce;\n                uint baseGasPrice;\n                uint gasPrice;\n                uint gasUsed;\n                uint gasCost;\n                uint payout;\n                uint fee;\n                address executedBy;\n                bytes4 abiSignature;\n                bool isCancelled;\n                bool wasCalled;\n                bool wasSuccessful;\n                bytes32 dataHash;\n        }\n\n        mapping (bytes32 => Call) key_to_calls;\n\n        /*\n         *  Getter methods for `Call` information\n         */\n        function getCallContractAddress(bytes32 callKey) public returns (address) {\n                return key_to_calls[callKey].contractAddress;\n        }\n\n        function getCallScheduledBy(bytes32 callKey) public returns (address) {\n                return key_to_calls[callKey].scheduledBy;\n        }\n\n        function getCallCalledAtBlock(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].calledAtBlock;\n        }\n\n        function getCallGracePeriod(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].gracePeriod;\n        }\n\n        function getCallTargetBlock(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].targetBlock;\n        }\n\n        function getCallBaseGasPrice(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].baseGasPrice;\n        }\n\n        function getCallGasPrice(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].gasPrice;\n        }\n\n        function getCallGasUsed(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].gasUsed;\n        }\n\n        function getCallABISignature(bytes32 callKey) public returns (bytes4) {\n                return key_to_calls[callKey].abiSignature;\n        }\n\n        function checkIfCalled(bytes32 callKey) public returns (bool) {\n                return key_to_calls[callKey].wasCalled;\n        }\n\n        function checkIfSuccess(bytes32 callKey) public returns (bool) {\n                return key_to_calls[callKey].wasSuccessful;\n        }\n\n        function checkIfCancelled(bytes32 callKey) public returns (bool) {\n                return key_to_calls[callKey].isCancelled;\n        }\n\n        function getCallDataHash(bytes32 callKey) public returns (bytes32) {\n                return key_to_calls[callKey].dataHash;\n        }\n\n        function getCallPayout(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].payout;\n        }\n\n        function getCallFee(bytes32 callKey) public returns (uint) {\n                return key_to_calls[callKey].fee;\n        }\n\n        /*\n         *  Data Registry API\n         */\n        bytes lastData;\n        uint lastDataLength;\n        bytes32 lastDataHash;\n\n        function getLastDataHash() public returns (bytes32) {\n                return lastDataHash;\n        }\n\n        function getLastDataLength() public returns (uint) {\n                return lastDataLength;\n        }\n\n        function getLastData() public returns (bytes) {\n                return lastData;\n        }\n\n        function getCallData(bytes32 callKey) public returns (bytes) {\n                return hash_to_data[key_to_calls[callKey].dataHash];\n        }\n\n        mapping (bytes32 => bytes) hash_to_data;\n\n        /*\n         *  Data registration API\n         */\n        //event DataRegistered(bytes32 indexed dataHash);\n\n        function registerData() public {\n                bytes trunc;\n                if (msg.data.length > 4) {\n                        trunc.length = msg.data.length - 4;\n                        for (uint i = 0; i < trunc.length; i++) {\n                                trunc[trunc.length - 1 - i] = msg.data[msg.data.length - 1 - i];\n                        }\n                }\n                hash_to_data[sha3(trunc)] = trunc;\n                lastDataHash = sha3(trunc);\n                lastDataLength = trunc.length;\n                lastData = trunc;\n\n                // Log it.\n                //DataRegistered(lastDataHash);\n        }\n\n        /*\n         *  Call execution API\n         */\n        CallerPool callerPool;\n\n        function getCallerPoolAddress() public returns (address) {\n                return address(callerPool);\n        }\n\n        // This number represents the constant gas cost of the addition\n        // operations that occur in `doCall` that cannot be tracked with\n        // msg.gas.\n        //\n        // NOTE: Currently this value seems to vary between 151761 and 151697.\n        // Until I can understand why this is happening, or account for it, we\n        // use the higher value.\n        uint constant EXTRA_CALL_GAS = 151761;\n        // uint constant EXTRA_CALL_GAS = 151697;\n\n        // This number represents the overall overhead involved in executing a\n        // scheduled call.\n        uint constant CALL_OVERHEAD = 145601;\n\n        //event CallExecuted(address indexed executedBy, bytes32 indexed callKey);\n        //event CallAborted(address indexed executedBy, bytes32 indexed callKey, bytes18 reason);\n\n        function doCall(bytes32 callKey) public {\n                uint gasBefore = msg.gas;\n\n                var call = key_to_calls[callKey];\n\n                if (call.wasCalled) {\n                        // The call has already been executed so don't do it again.\n                        //CallAborted(msg.sender, callKey, \"ALREADY CALLED\");\n                        return;\n                }\n\n                if (call.isCancelled) {\n                        // The call was cancelled so don't execute it.\n                        //CallAborted(msg.sender, callKey, \"CANCELLED\");\n                        return;\n                }\n\n                if (call.contractAddress == 0x0) {\n                        // This call key doesnt map to a registered call.\n                        //CallAborted(msg.sender, callKey, \"UNKNOWN\");\n                        return;\n                }\n\n                if (block.number < call.targetBlock) {\n                        // Target block hasnt happened yet.\n                        //CallAborted(msg.sender, callKey, \"TOO EARLY\");\n                        return;\n                }\n\n                if (block.number > call.targetBlock + call.gracePeriod) {\n                        // The blockchain has advanced passed the period where\n                        // it was allowed to be called.\n                        //CallAborted(msg.sender, callKey, \"TOO LATE\");\n                        return;\n                }\n\n                uint heldBalance = getCallMaxCost(callKey);\n\n                if (accountBalances[call.scheduledBy] < heldBalance) {\n                        // The scheduledBy's account balance is less than the\n                        // current gasLimit and thus potentiall can't pay for\n                        // the call.\n\n                        // Mark it as called since it was.\n                        call.wasCalled = true;\n                        \n                        // Log it.\n                        //CallAborted(msg.sender, callKey, \"INSUFFICIENT_FUNDS\");\n                        return;\n                }\n\n                // Check if this caller is allowed to execute the call.\n                if (callerPool.getPoolSize(callerPool.getActivePoolKey()) > 0) {\n                        address poolCaller = callerPool.getDesignatedCaller(callKey, call.targetBlock, call.gracePeriod, block.number);\n                        if (poolCaller != 0x0 && poolCaller != msg.sender) {\n                                // This call was reserved for someone from the\n                                // bonded pool of callers and can only be\n                                // called by them during this block window.\n                                //CallAborted(msg.sender, callKey, \"WRONG_CALLER\");\n                                return;\n                        }\n\n                        uint blockWindow = (block.number - call.targetBlock) / 4;\n                        if (blockWindow > 0) {\n                                // Someone missed their call so this caller\n                                // gets to claim their bond for picking up\n                                // their slack.\n                                callerPool.awardMissedBlockBonus(msg.sender, callKey, call.targetBlock, call.gracePeriod);\n                        }\n                }\n\n                // Log metadata about the call.\n                call.gasPrice = tx.gasprice;\n                call.executedBy = msg.sender;\n                call.calledAtBlock = block.number;\n\n                // Fetch the call data\n                var data = getCallData(callKey);\n\n                // During the call, we need to put enough funds to pay for the\n                // call on hold to ensure they are available to pay the caller.\n                _deductFunds(call.scheduledBy, heldBalance);\n\n                // Mark whether the function call was successful.\n                if (checkAuthorization(call.scheduledBy, call.contractAddress)) {\n                        call.wasSuccessful = authorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\n                }\n                else {\n                        call.wasSuccessful = unauthorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\n                }\n\n                // Add the held funds back into the scheduler's account.\n                _addFunds(call.scheduledBy, heldBalance);\n\n                // Mark the call as having been executed.\n                call.wasCalled = true;\n\n                // Log the call execution.\n                //CallExecuted(msg.sender, callKey);\n\n                // Compute the scalar (0 - 200) for the fee.\n                uint feeScalar = getCallFeeScalar(call.baseGasPrice, call.gasPrice);\n\n                // Log how much gas this call used.  EXTRA_CALL_GAS is a fixed\n                // amount that represents the gas usage of the commands that\n                // happen after this line.\n                call.gasUsed = (gasBefore - msg.gas + EXTRA_CALL_GAS);\n                call.gasCost = call.gasUsed * call.gasPrice;\n\n                // Now we need to pay the caller as well as keep fee.\n                // callerPayout -> call cost + 1%\n                // fee -> 1% of callerPayout\n                call.payout = call.gasCost * feeScalar * 101 / 10000;\n                call.fee = call.gasCost * feeScalar / 10000;\n\n                _deductFunds(call.scheduledBy, call.payout + call.fee);\n\n                _addFunds(msg.sender, call.payout);\n                _addFunds(owner, call.fee);\n        }\n\n        function getCallMaxCost(bytes32 callKey) public returns (uint) {\n                /*\n                 *  tx.gasprice * block.gaslimit\n                 *  \n                 */\n                // call cost + 2%\n                var call = key_to_calls[callKey];\n\n                uint gasCost = tx.gasprice * block.gaslimit;\n                uint feeScalar = getCallFeeScalar(call.baseGasPrice, tx.gasprice);\n\n                return gasCost * feeScalar * 102 / 10000;\n        }\n\n        function getCallFeeScalar(uint baseGasPrice, uint gasPrice) public returns (uint) {\n                /*\n                 *  Return a number between 0 - 200 to scale the fee based on\n                 *  the gas price set for the calling transaction as compared\n                 *  to the gas price of the scheduling transaction.\n                 *\n                 *  - number approaches zero as the transaction gas price goes\n                 *  above the gas price recorded when the call was scheduled.\n                 *\n                 *  - the number approaches 200 as the transaction gas price\n                 *  drops under the price recorded when the call was scheduled.\n                 *\n                 *  This encourages lower gas costs as the lower the gas price\n                 *  for the executing transaction, the higher the payout to the\n                 *  caller.\n                 */\n                if (gasPrice > baseGasPrice) {\n                        return 100 * baseGasPrice / gasPrice;\n                }\n                else {\n                        return 200 - 100 * baseGasPrice / (2 * baseGasPrice - gasPrice);\n                }\n        }\n\n        /*\n         *  Call Scheduling API\n         */\n\n        // The result of `sha()` so that we can validate that people aren't\n        // looking up call data that failed to register.\n        bytes32 constant emptyDataHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        function getCallKey(address scheduledBy, address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) public returns (bytes32) {\n                return sha3(scheduledBy, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n        }\n\n        // Ten minutes into the future.\n        uint constant MAX_BLOCKS_IN_FUTURE = 40;\n\n        //event CallScheduled(bytes32 indexed callKey);\n        //event CallRejected(bytes32 indexed callKey, bytes15 reason);\n\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) public {\n                /*\n                 * Primary API for scheduling a call.  Prior to calling this\n                 * the data should already have been registered through the\n                 * `registerData` API.\n                 */\n                bytes32 callKey = getCallKey(msg.sender, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n\n                if (dataHash != emptyDataHash && hash_to_data[dataHash].length == 0) {\n                        // Don't allow registering calls if the data hash has\n                        // not actually been registered.  The only exception is\n                        // the *emptyDataHash*.\n                        //CallRejected(callKey, \"NO_DATA\");\n                        return;\n                }\n\n                if (targetBlock < block.number + MAX_BLOCKS_IN_FUTURE) {\n                        // Don't allow scheduling further than\n                        // MAX_BLOCKS_IN_FUTURE\n                        //CallRejected(callKey, \"TOO_SOON\");\n                        return;\n                }\n                var call = key_to_calls[callKey];\n\n                if (call.contractAddress != 0x0) {\n                        //CallRejected(callKey, \"DUPLICATE\");\n                        return;\n                }\n\n                if (gracePeriod < 16) {\n                        //CallRejected(callKey, \"GRACE_TOO_SHORT\");\n                        return;\n                }\n\n                lastCallKey = callKey;\n\n                call.contractAddress = contractAddress;\n                call.scheduledBy = msg.sender;\n                call.nonce = nonce;\n                call.abiSignature = abiSignature;\n                call.dataHash = dataHash;\n                call.targetBlock = targetBlock;\n                call.gracePeriod = gracePeriod;\n                call.baseGasPrice = tx.gasprice;\n\n                placeCallInTree(lastCallKey);\n                rotateTree();\n\n                //CallScheduled(lastCallKey);\n        }\n\n        //event CallCancelled(bytes32 indexed callKey);\n\n        // Two minutes\n        uint constant MIN_CANCEL_WINDOW = 8;\n\n        function cancelCall(bytes32 callKey) public {\n                var call = key_to_calls[callKey];\n                if (call.scheduledBy != msg.sender) {\n                        // Nobody but the scheduler can cancel a call.\n                        return;\n                }\n                if (call.wasCalled) {\n                        // No need to cancel a call that already was executed.\n                        return;\n                }\n                if (call.targetBlock - MIN_CANCEL_WINDOW <= block.number) {\n                        // Call cannot be cancelled this close to execution.\n                        return;\n                }\n                call.isCancelled = true;\n                //CallCancelled(callKey);\n        }\n\n        function __throw() internal {\n                int[] x;\n                x[1];\n        }\n}\n",
            "userDoc": {
                "methods": {}
            }
        }
    }
}